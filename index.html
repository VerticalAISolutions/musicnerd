<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>MusicNerd</title>
    <link rel="icon" href="buttons/Music.svg" type="image/svg+xml">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&display=swap" rel="stylesheet">
    <style>
        :root {
            --electric-aqua: #87F1FF;
            --icy-aqua: #C0F5FA;
            --old-rose: #BD8B9C;
            --cherry-rose: #AF125A;
            --dark-walnut: #582B11;
            --dark-blue: #0f1a2e;
        }
        #wavyWrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }
        #wavyBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        /* Mobile: Animation ausblendbar */
        @media (max-width: 768px) {
            #wavyWrapper {
                transition: opacity 0.5s ease;
            }
            #wavyWrapper.wavy-hidden {
                opacity: 0;
                pointer-events: none;
            }
        }
        * {
            box-sizing: border-box;
        }
        html, body {
            overflow-x: hidden;
        }
        body {
            font-family: 'DM Sans', sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            padding-bottom: 60px;
            background: var(--dark-blue);
            color: var(--icy-aqua);
            min-height: 100vh;
        }

        /* Footer */
        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 15px;
            text-align: center;
            font-size: 14px;
            color: var(--old-rose);
            opacity: 0.7;
        }
        .footer a {
            color: var(--old-rose);
            text-decoration: none;
        }
        @media (hover: hover) {
            .footer a:hover {
                color: var(--icy-aqua);
                opacity: 1;
            }
        }
        /* Mobile: Footer immer am Bottom, scrollt mit bei langem Inhalt */
        @media (max-width: 768px), (hover: none) {
            body {
                display: flex;
                flex-direction: column;
                min-height: 100vh;
            }
            body .container {
                flex: 1 1 auto;
            }
            .footer {
                position: relative;
                margin-top: auto;
                padding-top: 24px;
            }
        }

        /* Intro Screen */
        .intro-screen {
            text-align: center;
            padding: 30px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 120px);
        }
        .intro-title {
            font-size: 52px;
            font-weight: 700;
            color: var(--electric-aqua);
            position: relative;
            z-index: 1;
            opacity: 0;
            animation: fadeInTitle 0.8s ease-out forwards;
            animation-delay: 0.5s;
            letter-spacing: -0.5px;
        }
        @keyframes fadeInTitle {
            to { opacity: 1; }
        }
        .intro-lead {
            font-size: 18px;
            line-height: 1.6;
            color: var(--icy-aqua);
            margin-bottom: 35px;
            text-align: center;
        }
        .intro-section {
            text-align: left;
            margin-bottom: 28px;
        }
        .intro-section-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--electric-aqua);
            margin-bottom: 8px;
        }
        .intro-section-text {
            font-size: 16px;
            line-height: 1.6;
            color: var(--old-rose);
        }
        .intro-ready {
            font-size: 22px;
            font-weight: 600;
            color: var(--icy-aqua);
            margin-top: 40px;
            margin-bottom: 15px;
        }
        .intro-btn {
            width: auto;
            padding: 18px 60px;
            font-size: 20px;
            font-family: 'DM Sans', sans-serif;
            font-weight: 700;
            background: var(--cherry-rose);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(175, 18, 90, 0.4);
        }
        /* Hand-drawn circle animation */
        .intro-title-wrapper {
            position: relative;
            display: inline-block;
            margin-bottom: 80px;
        }
        .intro-title-svg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 140%;
            height: 200%;
            pointer-events: none;
        }
        .intro-title-circle {
            fill: none;
            stroke: var(--cherry-rose);
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            animation: drawCircle 2.5s ease-out forwards;
            animation-delay: 0.3s;
        }
        @keyframes drawCircle {
            to {
                stroke-dashoffset: 0;
            }
        }

        /* Text loop animation for claims */
        .intro-text-loop {
            height: 50px;
            overflow: hidden;
            margin-bottom: 70px;
            opacity: 0;
        }
        .intro-text-loop.active {
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        .intro-text-loop-item {
            font-size: 28px;
            font-weight: 600;
            color: var(--icy-aqua);
            opacity: 0;
            transform: translateY(20px);
            animation: textLoopIn 0.4s ease-out forwards;
        }
        .intro-text-loop-item.exit {
            animation: textLoopOut 0.3s ease-in forwards;
        }
        @keyframes textLoopIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        @keyframes textLoopOut {
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }
        .intro-secondary-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-top: 40px;
            padding: 10px 20px;
            font-size: 15px;
            font-family: 'DM Sans', sans-serif;
            font-weight: 500;
            color: var(--old-rose);
            background: transparent;
            border: none;
            cursor: pointer;
            letter-spacing: 0.3px;
        }
        /* How-it-works Modal */
        .hiw-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 26, 46, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .hiw-modal-overlay.visible {
            display: flex;
        }
        .hiw-modal-box {
            background: var(--dark-blue);
            border: 2px solid var(--electric-aqua);
            border-radius: 16px;
            padding: 30px;
            max-width: 480px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 8px 32px rgba(135, 241, 255, 0.15);
        }
        .hiw-modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 32px;
            height: 32px;
            background: transparent;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease, opacity 0.2s ease;
            opacity: 0.7;
        }
        .hiw-modal-close img {
            width: 24px;
            height: 24px;
            filter: invert(60%) sepia(15%) saturate(500%) hue-rotate(290deg) brightness(90%) contrast(90%);
        }
        @media (hover: hover) {
            .hiw-modal-close:hover {
                transform: scale(1.1);
                opacity: 1;
            }
            .hiw-modal-close:hover img {
                filter: invert(90%) sepia(20%) saturate(500%) hue-rotate(140deg) brightness(100%) contrast(90%);
            }
        }
        .hiw-modal-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--electric-aqua);
            margin: 0 0 25px 0;
            text-align: center;
        }
        .hiw-steps {
            list-style: none;
            padding: 0;
            margin: 0 0 30px 0;
        }
        .hiw-step {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            align-items: flex-start;
        }
        .hiw-step:last-child {
            margin-bottom: 0;
        }
        .hiw-step-number {
            flex-shrink: 0;
            width: 28px;
            height: 28px;
            background: var(--cherry-rose);
            border-radius: 50%;
            color: white;
            font-size: 14px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .hiw-step-text {
            font-size: 15px;
            line-height: 1.5;
            color: var(--icy-aqua);
        }
        .hiw-step-text strong {
            color: var(--electric-aqua);
        }
        .hiw-modal-btn {
            width: 100%;
            padding: 16px;
            font-size: 18px;
            font-family: 'DM Sans', sans-serif;
            font-weight: 700;
            background: var(--cherry-rose);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            margin-top: 10px;
        }
        body.modal-open {
            overflow: hidden;
        }
        .setup-nav {
            display: flex;
            gap: 10px;
            margin-top: 28px;
            width: 100%;
        }
        .setup-nav .back-btn {
            flex: 1;
            padding: 14px;
            font-size: 16px;
            font-family: 'DM Sans', sans-serif;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.05);
            color: var(--old-rose);
            border: 2px solid var(--old-rose);
            border-radius: 10px;
            cursor: pointer;
        }
        .setup-nav .next-btn {
            flex: 2;
            padding: 14px;
            font-size: 16px;
            font-family: 'DM Sans', sans-serif;
            font-weight: 600;
            background: var(--cherry-rose);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        h1 {
            color: var(--electric-aqua);
            text-align: center;
            margin-bottom: 30px;
            font-weight: 700;
        }
        .container {
            width: 100%;
        }

        /* Setup Screen */
        .setup-screen {
            width: 100%;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
            text-align: center;
        }
        /* Mobile: Inhalt zentriert, halbtransparenter Hintergrund */
        @media (max-width: 768px), (hover: none) {
            .setup-screen {
                display: flex;
                flex-direction: column;
                align-items: center;
                width: calc(100% + 40px);
                margin-left: -20px;
                margin-right: -20px;
                padding: 20px;
                box-sizing: border-box;
                background: rgba(15, 26, 46, 0.92);
            }
            /* Alle direkten Kinder zentriert, einheitliche Breite */
            .setup-screen > * {
                width: 100%;
                max-width: 360px;
                margin-left: auto;
                margin-right: auto;
                box-sizing: border-box;
            }
            .setup-screen h1 {
                text-align: center;
            }
            /* Game-Screen: kein Fill/Hintergrund */
            .game-screen {
                background: none !important;
            }
        }
        .setup-section {
            margin-bottom: 12px;
            padding-top: 20px;
            text-align: left;
            width: 100%;
        }
        @media (max-width: 768px), (hover: none) {
            .setup-section {
                max-width: 360px;
                margin-left: auto;
                margin-right: auto;
            }
            .setup-screen .setup-nav {
                width: 100%;
                max-width: 360px;
                margin-left: auto;
                margin-right: auto;
            }
        }
        .setup-label {
            font-size: 16px;
            font-weight: 600;
            color: var(--electric-aqua);
            margin-bottom: 12px;
            display: block;
        }

        /* Player Setup */
        .player-count, .round-count {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .round-count-btn {
            min-width: 50px;
            height: 44px;
            padding: 0 12px;
            border: 2px solid var(--old-rose);
            background: rgba(255, 255, 255, 0.05);
            color: var(--icy-aqua);
            border-radius: 8px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .round-count-btn.selected {
            background: var(--cherry-rose);
            border-color: var(--cherry-rose);
            color: white;
        }
        .player-count-btn {
            width: 44px;
            height: 44px;
            border: 2px solid var(--old-rose);
            background: rgba(255, 255, 255, 0.05);
            color: var(--icy-aqua);
            border-radius: 8px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .player-count-btn.selected {
            background: var(--cherry-rose);
            border-color: var(--cherry-rose);
            color: white;
        }
        .player-inputs {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .player-name-input {
            padding: 12px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(192, 245, 250, 0.1);
            color: var(--icy-aqua);
            font-family: 'DM Sans', sans-serif;
            font-size: 16px;
        }
        .player-name-input::placeholder {
            color: var(--old-rose);
            opacity: 0.6;
        }
        .player-name-input:focus {
            outline: 2px solid var(--electric-aqua);
        }

        /* Genre Grid: Mobil 2 Spalten, Desktop 4 Spalten */
        .genre-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        @media (min-width: 769px) {
            .genre-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 8px;
            }
        }
        .genre-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: var(--dark-blue);
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        /* Desktop: Genre-Buttons ca. 4 % heller als Standard, weniger hell als Hover */
        @media (min-width: 769px) {
            .genre-item {
                background: #192336;
            }
        }
        .genre-item.selected {
            background: var(--cherry-rose);
        }
        .genre-checkbox {
            width: 18px;
            height: 18px;
            border: 2px solid var(--old-rose);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        .genre-item.selected .genre-checkbox {
            background: var(--cherry-rose);
            border-color: var(--cherry-rose);
        }
        .genre-checkbox::after {
            content: '';
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 2px;
            opacity: 0;
        }
        .genre-item.selected .genre-checkbox::after {
            opacity: 1;
        }
        .genre-name {
            font-size: 13px;
            color: var(--icy-aqua);
        }

        /* Year Range Slider */
        .year-display {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            font-size: 16px;
            font-weight: 600;
            color: var(--icy-aqua);
        }
        .range-slider {
            position: relative;
            height: 36px;
        }
        .range-slider input[type="range"] {
            position: absolute;
            width: 100%;
            height: 6px;
            background: transparent;
            pointer-events: none;
            -webkit-appearance: none;
        }
        .range-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            background: var(--cherry-rose);
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            border: 3px solid var(--icy-aqua);
        }
        .slider-track {
            position: absolute;
            top: 8px;
            width: 100%;
            height: 6px;
            background: rgba(189, 139, 156, 0.3);
            border-radius: 3px;
        }
        .slider-range {
            position: absolute;
            top: 8px;
            height: 6px;
            background: var(--cherry-rose);
            border-radius: 3px;
        }

        /* Buttons */
        .start-btn {
            width: 100%;
            padding: 16px;
            font-size: 18px;
            font-family: 'DM Sans', sans-serif;
            font-weight: 700;
            background: var(--cherry-rose);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            margin-top: 15px;
            transition: background 0.2s;
        }
        @media (hover: hover) {
            .start-btn:hover {
                background: #c91a6a;
            }
        }
        .start-btn:disabled {
            background: var(--old-rose);
            cursor: not-allowed;
        }

        /* Game Screen */
        .game-screen {
            display: none;
            width: 100%;
            text-align: center;
        }
        .game-screen.visible {
            display: block;
        }
        .play-btn-wrapper {
            position: relative;
            width: 100px;
            height: 100px;
            margin: 15px auto;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .play-countdown-ring {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        /* Ein Icon: nur Lade-Ring ODER Ring + Dreieck (Play-Button) */
        .play-countdown-bg {
            stroke: var(--electric-aqua);
            stroke-width: 3;
            opacity: 0.4;
        }
        .play-btn-wrapper:has(.play-btn.loading) .play-countdown-bg {
            display: none;
        }
        .play-loading-tail, .play-loading-arc {
            display: none;
        }
        /* Equalizer Ladeanimation */
        .equalizer {
            display: none;
            align-items: flex-end;
            justify-content: center;
            gap: 6px;
            height: 70px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
        }
        .play-btn-wrapper:has(.play-btn.loading) .equalizer {
            display: flex;
        }
        .play-btn-wrapper:has(.play-btn.loading) .play-btn {
            opacity: 0;
        }
        .eq-bar {
            width: 7px;
            border-radius: 4px;
            transform-origin: bottom;
            animation: eqBounce 1.2s ease-in-out infinite;
        }
        .eq-bar:nth-child(1) { height: 20px; animation-delay: 0s; background: var(--cherry-rose); }
        .eq-bar:nth-child(2) { height: 35px; animation-delay: 0.2s; background: var(--old-rose); }
        .eq-bar:nth-child(3) { height: 50px; animation-delay: 0.4s; background: var(--electric-aqua); }
        .eq-bar:nth-child(4) { height: 40px; animation-delay: 0.15s; background: var(--old-rose); }
        .eq-bar:nth-child(5) { height: 28px; animation-delay: 0.35s; background: var(--cherry-rose); }
        .eq-bar:nth-child(6) { height: 45px; animation-delay: 0.25s; background: var(--electric-aqua); }
        .eq-bar:nth-child(7) { height: 22px; animation-delay: 0.5s; background: var(--cherry-rose); }
        @keyframes eqBounce {
            0%, 100% { transform: scaleY(0.2); }
            50% { transform: scaleY(1); }
        }
        .play-countdown-progress {
            stroke: var(--electric-aqua);
            stroke-linecap: round;
            transition: stroke-dashoffset 0.2s linear;
            visibility: hidden;
        }
        .play-btn-wrapper:has(.play-btn.playing) .play-countdown-progress {
            visibility: visible;
        }
        .play-btn-wrapper:has(.play-btn.loading) .play-countdown-progress {
            visibility: hidden;
        }
        /* Mobil: kein Background bei Ladeanimation */
        @media (max-width: 768px), (hover: none) {
            .game-screen .play-btn-wrapper,
            .game-screen .status {
                background: none;
            }
        }
        .play-btn {
            position: relative;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            margin: 0;
            background: none;
            border: none;
            box-shadow: none;
            cursor: pointer;
            font-size: 40px;
            color: var(--electric-aqua);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            line-height: 1;
            transition: color 0.2s ease, opacity 0.25s ease;
        }
        .play-btn .play-btn-icon {
            display: inline-block;
            width: 60px;
            height: 60px;
            filter: invert(91%) sepia(27%) saturate(730%) hue-rotate(143deg) brightness(102%) contrast(101%);
        }
        .play-btn .pause-icon {
            display: none;
        }
        @media (hover: hover) {
            .play-btn:hover:not(:disabled) {
                color: var(--icy-aqua);
            }
        }
        .play-btn:active:not(:disabled) {
            opacity: 0.9;
        }
        .play-btn:disabled {
            cursor: not-allowed;
        }
        .play-btn:disabled .play-btn-icon {
            opacity: 0.4;
        }
        .play-btn.loading .play-btn-icon {
            opacity: 0;
        }
        .play-btn .play-btn-countdown { display: none !important; }
        .play-btn.playing .play-icon { display: none !important; }
        .play-btn.playing .pause-icon { display: inline-block !important; }
        .play-btn.playing {
            color: var(--electric-aqua);
        }
        .play-btn:not(.loading) .play-btn-icon {
            transition: opacity 0.25s ease;
        }
        .round-counter {
            font-size: 13px;
            color: var(--old-rose);
            text-align: center;
            margin-bottom: 8px;
            letter-spacing: 1px;
        }
        .status {
            font-size: 26px;
            font-weight: 600;
            text-align: center;
            min-height: 3em;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            color: var(--electric-aqua);
            margin-bottom: 20px;
        }
        .status.status-loading {
            /* gleicher Stil wie .status, nur fade-in bei Wechsel */
        }
        .status.status-loading.fade-in {
            animation: statusFadeIn 0.6s ease-out;
        }
        @keyframes statusFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        /* Auf Mobilgeräten: Animation erlauben, aber will-change begrenzen */
        @media (max-width: 768px), (hover: none) {
            .status {
                contain: layout style;
            }
            .status.status-loading.fade-in {
                animation: statusFadeIn 0.6s ease-out;
                opacity: 1;
                will-change: opacity;
            }
        }

        /* Player Guess Section */
        .players-guess-section {
            display: none;
        }
        .players-guess-section.visible {
            display: block;
        }
        .player-guess-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
            padding: 12px;
            background: rgba(192, 245, 250, 0.08);
            border-radius: 10px;
        }
        .player-guess-name {
            flex: 1;
            font-size: 16px;
            font-weight: 600;
            color: var(--icy-aqua);
            text-align: left;
        }
        .player-guess-input {
            width: 90px;
            padding: 10px;
            font-size: 20px;
            text-align: center;
            border: none;
            border-radius: 8px;
            background: rgba(192, 245, 250, 0.15);
            color: var(--electric-aqua);
            font-family: 'DM Sans', sans-serif;
            font-weight: bold;
            letter-spacing: 2px;
        }
        .player-guess-input.revealed {
            animation: revealGuess 0.5s ease forwards;
            background: rgba(135, 241, 255, 0.25);
        }
        @keyframes revealGuess {
            0% { transform: scale(1.15); opacity: 0; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .player-guess-input:focus {
            outline: 2px solid var(--electric-aqua);
        }
        .player-guess-input::placeholder {
            color: var(--old-rose);
            opacity: 0.5;
            font-size: 14px;
        }
        .player-guess-input.submitted {
            background: rgba(175, 18, 90, 0.3);
        }
        .submit-all-btn {
            width: 100%;
            padding: 14px;
            font-size: 16px;
            font-family: 'DM Sans', sans-serif;
            font-weight: 600;
            background: var(--cherry-rose);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 10px;
        }
        @media (hover: hover) {
            .submit-all-btn:hover {
                background: #c91a6a;
            }
        }
        .submit-all-btn:disabled {
            background: var(--old-rose);
            cursor: not-allowed;
        }

        /* Result */
        .result {
            position: relative;
            margin-top: 20px;
            padding: 20px;
            padding-bottom: 60px;
            background: rgba(192, 245, 250, 0.1);
            border-radius: 16px;
            display: none;
        }
        .result.visible {
            display: block;
        }
        .result-year {
            font-size: 42px;
            font-weight: bold;
            color: var(--electric-aqua);
        }
        .result-year-note {
            font-size: 14px;
            color: var(--old-rose);
            opacity: 0.9;
            margin-top: 4px;
            margin-bottom: 8px;
        }
        .result-artwork {
            width: 150px;
            height: 150px;
            border-radius: 12px;
            object-fit: cover;
            margin: 12px auto 8px;
            display: block;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
        }
        .result-song-title {
            font-size: 22px;
            font-weight: 600;
            color: var(--icy-aqua);
            margin: 8px 0 4px 0;
            line-height: 1.3;
        }
        .result-artist-name {
            font-size: 18px;
            font-weight: 500;
            color: var(--old-rose);
            margin: 0 0 16px 0;
            line-height: 1.3;
        }
        .result-song-info {
            text-align: left;
            font-size: 15px;
            line-height: 1.6;
            color: var(--icy-aqua);
            margin: 16px 0;
            padding: 14px;
            background: rgba(192, 245, 250, 0.08);
            border-radius: 12px;
        }
        .player-results {
            margin-top: 15px;
            text-align: left;
        }
        .player-result-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            margin-bottom: 6px;
            border-radius: 8px;
            font-size: 14px;
            flex-wrap: wrap;
            gap: 4px;
        }
        @media (max-width: 400px) {
            .player-result-row {
                flex-direction: column;
                align-items: flex-start;
            }
            .player-result-diff {
                font-size: 13px !important;
            }
        }
        .player-result-row.perfect {
            background: rgba(135, 241, 255, 0.2);
        }
        .player-result-row.close {
            background: rgba(189, 139, 156, 0.2);
        }
        .player-result-row.far {
            background: rgba(175, 18, 90, 0.2);
        }
        .player-result-name {
            font-weight: 600;
            color: var(--icy-aqua);
        }
        .player-result-diff {
            color: var(--icy-aqua);
            font-size: 17px;
            font-weight: 600;
        }
        .player-result-row.perfect .player-result-diff {
            color: var(--electric-aqua);
        }

        /* Streaming Links */
        .streaming-links {
            margin-top: 15px;
            margin-bottom: 36px;
            padding-top: 15px;
            border-top: 1px solid rgba(189, 139, 156, 0.3);
        }
        .streaming-label {
            font-size: 11px;
            color: var(--old-rose);
            margin-bottom: 18px;
        }
        .streaming-buttons {
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .stream-link {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 6px 12px;
            border-radius: 16px;
            text-decoration: none;
            font-size: 11px;
            font-weight: 500;
        }
        .stream-link.spotify { background: #1DB954; color: white; }
        .stream-link.apple { background: #fc3c44; color: white; }
        .stream-link.deezer { background: #a238ff; color: white; }
        .stream-link.tidal { background: #000; color: white; }

        .result-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 36px;
            flex-wrap: wrap;
        }
        .result-btn {
            padding: 12px 25px;
            font-size: 14px;
            font-family: 'DM Sans', sans-serif;
            font-weight: 600;
            background: var(--old-rose);
            color: var(--dark-blue);
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        @media (hover: hover) {
            .result-btn:hover {
                background: var(--icy-aqua);
            }
        }
        /* Difficulty Selection */
        .difficulty-buttons {
            display: flex;
            gap: 8px;
        }
        .difficulty-btn {
            flex: 1;
            padding: 12px 8px;
            font-size: 13px;
            font-family: 'DM Sans', sans-serif;
            font-weight: 600;
            border: 2px solid var(--old-rose);
            background: rgba(255, 255, 255, 0.05);
            color: var(--icy-aqua);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .difficulty-btn.selected {
            background: var(--cherry-rose);
            border-color: var(--cherry-rose);
            color: white;
        }
        @media (hover: hover) {
            .difficulty-btn:hover:not(.selected) {
                background: rgba(255, 255, 255, 0.1);
                border-color: var(--electric-aqua);
            }
        }
        /* Letzte Runde Overlay */
        .last-round-overlay {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 26, 46, 0.92);
            z-index: 100;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }
        .last-round-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .last-round-overlay.fade-out {
            opacity: 0;
        }
        .last-round-text {
            font-size: 48px;
            font-weight: 700;
            color: var(--electric-aqua);
            text-align: center;
            transform: scale(0.5);
            opacity: 0;
            transition: transform 0.5s ease, opacity 0.5s ease;
        }
        .last-round-overlay.visible .last-round-text {
            transform: scale(1);
            opacity: 1;
        }
        .standings-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 26, 46, 0.95);
            z-index: 100;
            padding: 20px;
            overflow-y: auto;
        }
        .standings-overlay.visible {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .standings-content {
            max-width: 400px;
            width: 100%;
            text-align: center;
        }
        .standings-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--electric-aqua);
            margin-bottom: 10px;
        }
        .standings-round {
            font-size: 14px;
            color: var(--old-rose);
            margin-bottom: 20px;
        }
        .standings-list {
            text-align: left;
        }
        .standings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 16px;
            margin-bottom: 8px;
            border-radius: 10px;
            background: rgba(192, 245, 250, 0.1);
        }
        .standings-row:first-child {
            background: rgba(135, 241, 255, 0.2);
        }
        .standings-rank {
            font-size: 18px;
            font-weight: 700;
            color: var(--old-rose);
            width: 30px;
        }
        .standings-row:first-child .standings-rank {
            color: var(--electric-aqua);
        }
        .standings-name {
            flex: 1;
            font-size: 16px;
            font-weight: 600;
            color: var(--icy-aqua);
        }
        .standings-score {
            font-size: 16px;
            color: var(--old-rose);
            text-align: right;
        }
        .standings-score span {
            font-weight: 700;
            color: var(--electric-aqua);
        }
        @media (max-width: 500px) {
            .standings-row {
                flex-wrap: wrap;
                padding: 12px 14px;
            }
            .standings-rank {
                font-size: 16px;
                width: 26px;
            }
            .standings-name {
                font-size: 15px;
            }
            .standings-score {
                width: 100%;
                margin-top: 6px;
                padding-left: 26px;
                font-size: 13px;
                text-align: left;
            }
        }
        .standings-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 25px;
        }
        .close-standings-btn {
            padding: 14px 30px;
            font-size: 16px;
            font-family: 'DM Sans', sans-serif;
            font-weight: 600;
            background: var(--cherry-rose);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        .restart-btn {
            padding: 14px 30px;
            font-size: 16px;
            font-family: 'DM Sans', sans-serif;
            font-weight: 600;
            background: transparent;
            color: var(--electric-aqua);
            border: 2px solid var(--electric-aqua);
            border-radius: 10px;
            cursor: pointer;
        }

        /* Genre-Popup (kein Genre ausgewählt) */
        .genre-popup-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(15, 26, 46, 0.9);
            z-index: 200;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .genre-popup-overlay.visible {
            display: flex;
        }
        .genre-popup-box {
            background: var(--dark-blue);
            border: 2px solid var(--electric-aqua);
            border-radius: 16px;
            padding: 28px 32px;
            text-align: center;
            max-width: 320px;
            box-shadow: 0 8px 32px rgba(135, 241, 255, 0.15);
        }
        .genre-popup-text {
            font-size: 20px;
            font-weight: 600;
            color: var(--electric-aqua);
            margin: 0 0 22px 0;
        }
        .genre-popup-btn {
            padding: 12px 28px;
            font-size: 16px;
            font-family: 'DM Sans', sans-serif;
            font-weight: 600;
            background: var(--cherry-rose);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        @media (hover: hover) {
            .genre-popup-btn:hover {
                background: #c91a6a;
            }
        }

        /* Mobile-first responsive adjustments */

        /* Improve touch targets */
        .range-slider {
            height: 44px;
            padding: 10px 0;
        }
        .range-slider input[type="range"]::-webkit-slider-thumb {
            width: 28px;
            height: 28px;
        }
        .range-slider input[type="range"]::-moz-range-thumb {
            width: 28px;
            height: 28px;
            background: var(--cherry-rose);
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid var(--icy-aqua);
        }
        .slider-track {
            top: 19px;
        }
        .slider-range {
            top: 19px;
        }

        /* Prevent zoom on input focus (iOS) */
        input[type="text"],
        input[type="number"] {
            font-size: 16px;
        }

        /* Hover-States nur für Geräte mit echtem Hover (Maus) */
        @media (hover: hover) {
            .intro-btn:hover {
                background: #c91a6a;
            }
            .intro-secondary-btn:hover {
                color: var(--electric-aqua);
            }
            .hiw-modal-btn:hover {
                background: #c91a6a;
            }
            .setup-nav .back-btn:hover {
                background: rgba(255, 255, 255, 0.1);
                border-color: var(--icy-aqua);
                color: var(--icy-aqua);
            }
            .setup-nav .next-btn:hover {
                background: #c91a6a;
            }
            .round-count-btn:hover:not(.selected) {
                background: rgba(255, 255, 255, 0.1);
                border-color: var(--electric-aqua);
            }
            .player-count-btn:hover:not(.selected) {
                background: rgba(255, 255, 255, 0.1);
                border-color: var(--electric-aqua);
            }
            .genre-item:hover:not(.selected) {
                background: #1a2d4a;
            }
        }

        /* Better touch feedback */
        .player-count-btn:active,
        .genre-item:active,
        .difficulty-btn:active,
        .intro-btn:active,
        .start-btn:active,
        .result-btn:active,
        .setup-nav button:active {
            transform: scale(0.97);
        }

        /* Small phones (< 360px) */
        @media (max-width: 359px) {
            body {
                padding: 15px;
                padding-bottom: 55px;
            }
            .intro-title {
                font-size: 36px;
            }
            .intro-lead {
                font-size: 15px;
            }
            .intro-section-title {
                font-size: 17px;
            }
            .intro-section-text {
                font-size: 14px;
            }
            h1 {
                font-size: 24px;
            }
            .genre-name {
                font-size: 12px;
            }
            .player-count-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
            .play-btn {
                width: 90px;
                height: 90px;
                font-size: 36px;
            }
            .result-year {
                font-size: 36px;
            }
        }

        /* Tablets and larger (>= 768px) */
        @media (min-width: 768px) {
            body {
                padding: 30px;
                padding-bottom: 70px;
            }
            .intro-title {
                font-size: 60px;
            }
            .intro-lead {
                font-size: 20px;
            }
            .intro-section-title {
                font-size: 22px;
            }
            h1 {
                font-size: 32px;
            }
            .genre-item {
                padding: 12px 14px;
            }
            .genre-name {
                font-size: 14px;
            }
            .play-btn {
                width: 120px;
                height: 120px;
                font-size: 48px;
            }
            .player-guess-row {
                padding: 14px 16px;
            }
            .result {
                padding: 25px;
                padding-bottom: 65px;
            }
            .result-year {
                font-size: 48px;
            }
            .result-song-title {
                font-size: 24px;
            }
            .result-artist-name {
                font-size: 20px;
            }
            .standings-content {
                max-width: 450px;
            }
        }

        /* Desktop (>= 1024px) */
        @media (min-width: 1024px) {
            .intro-screen {
                padding: 50px 0;
            }
        }

        /* Landscape mode on phones */
        @media (max-height: 500px) and (orientation: landscape) {
            .intro-screen {
                padding: 15px 0;
                min-height: auto;
            }
            .intro-title {
                font-size: 32px;
                margin-bottom: 20px;
            }
            .intro-lead {
                margin-bottom: 20px;
            }
            .intro-section {
                margin-bottom: 15px;
            }
            .intro-ready {
                margin-top: 20px;
            }
            .play-btn {
                width: 80px;
                height: 80px;
                font-size: 32px;
                margin: 10px 0;
            }
            .standings-overlay {
                padding: 15px;
            }
        }

        /* Safe area for notched phones */
        @supports (padding: env(safe-area-inset-bottom)) {
            body {
                padding-bottom: calc(60px + env(safe-area-inset-bottom));
            }
            .footer {
                padding-bottom: calc(12px + env(safe-area-inset-bottom));
            }
        }
    </style>
</head>
<body>
    <div id="wavyWrapper">
        <canvas id="wavyBackground"></canvas>
    </div>
    <div class="container">
        <!-- Intro Screen -->
        <div class="intro-screen" id="introScreen">
            <div class="intro-title-wrapper">
                <svg class="intro-title-svg" viewBox="0 0 300 100" preserveAspectRatio="none">
                    <path class="intro-title-circle"
                          d="M 280 30
                             C 320 70, 280 90, 150 85
                             C 30 80, 10 60, 20 40
                             C 30 20, 80 15, 150 15
                             C 220 15, 270 25, 270 35" />
                </svg>
                <div class="intro-title">MusicNerd</div>
            </div>

            <div class="intro-text-loop" id="introTextLoop">
                <div class="intro-text-loop-item">30 Sekunden hören.</div>
            </div>

            <button class="intro-btn" onclick="showSetup()">Spiel starten</button>
            <button class="intro-secondary-btn" onclick="showHowItWorksModal()" id="hiwTrigger"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" style="opacity:0.8"><circle cx="8" cy="8" r="7" stroke="currentColor" stroke-width="1.5"/><text x="8" y="11.5" text-anchor="middle" fill="currentColor" font-size="10" font-weight="600">?</text></svg>So funktioniert's</button>
        </div>

        <!-- Setup Screen 1: Players -->
        <div class="setup-screen" id="setupPlayers" style="display: none;">
            <h1 style="margin-top: 0;">Wer spielt mit?</h1>
            <div class="setup-section">
                <label class="setup-label">Anzahl Spieler</label>
                <div class="player-count" id="playerCount"></div>
            </div>
            <div class="setup-section">
                <label class="setup-label">Namen</label>
                <div class="player-inputs" id="playerInputs"></div>
            </div>
            <div class="setup-section">
                <label class="setup-label">Anzahl Runden</label>
                <div class="round-count" id="roundCount"></div>
            </div>
            <div class="setup-nav" style="display:block;">
                <button class="next-btn" onclick="showSetupOptions()" style="width:100%;">Weiter</button>
            </div>
        </div>

        <!-- Setup Screen 2: Options -->
        <div class="setup-screen" id="setupOptions" style="display: none;">
            <h1 style="margin-top: 0;">Spieloptionen</h1>
            <!-- Genres -->
            <div class="setup-section">
                <label class="setup-label">Genres</label>
                <div class="genre-grid" id="genreGrid"></div>
            </div>

            <!-- Year Range -->
            <div class="setup-section">
                <label class="setup-label">Zeitraum</label>
                <div class="year-display">
                    <span id="yearMin">1940</span>
                    <span id="yearMax">2025</span>
                </div>
                <div class="range-slider">
                    <div class="slider-track"></div>
                    <div class="slider-range" id="sliderRange"></div>
                    <input type="range" id="rangeMin" min="1940" max="2025" value="1940">
                    <input type="range" id="rangeMax" min="1940" max="2025" value="2025">
                </div>
            </div>

            <!-- Difficulty -->
            <div class="setup-section">
                <label class="setup-label">Schwierigkeit</label>
                <div class="difficulty-buttons" id="difficultyButtons"></div>
            </div>

            <div class="setup-nav">
                <button class="back-btn" onclick="showSetupPlayers()">Zurück</button>
                <button class="next-btn" id="startBtn" onclick="startGame()">Spiel starten</button>
            </div>
        </div>

        <!-- Game Screen -->
        <div class="game-screen" id="gameScreen">
            <div class="play-btn-wrapper" id="playBtnWrapper">
                <svg class="play-countdown-ring" viewBox="0 0 100 100" aria-hidden="true">
                    <circle class="play-countdown-bg" cx="50" cy="50" r="47" fill="none" stroke-width="4"/>
                    <circle class="play-loading-tail" cx="50" cy="50" r="47" fill="none" stroke-width="2" stroke-dasharray="74 221" stroke-linecap="round"/>
                    <circle class="play-loading-arc" cx="50" cy="50" r="47" fill="none" stroke-width="2.5" stroke-dasharray="28 267" stroke-linecap="round"/>
                    <circle id="playCountdownRing" class="play-countdown-progress" cx="50" cy="50" r="47" fill="none" stroke-width="3" stroke-dasharray="295.31" stroke-dashoffset="0" transform="rotate(-90 50 50)"/>
                </svg>
                <button type="button" class="play-btn" id="playBtn" onclick="playPreview()" aria-label="Abspielen"><img class="play-btn-icon play-icon" src="buttons/Play.svg" alt="Play"><img class="play-btn-icon pause-icon" src="buttons/Pause.svg" alt="Pause" style="display:none;"><span class="play-btn-countdown" id="playBtnCountdown"></span></button>
                <div class="equalizer">
                    <div class="eq-bar"></div>
                    <div class="eq-bar"></div>
                    <div class="eq-bar"></div>
                    <div class="eq-bar"></div>
                    <div class="eq-bar"></div>
                    <div class="eq-bar"></div>
                    <div class="eq-bar"></div>
                </div>
            </div>
            <div class="round-counter" id="roundCounter"></div>
            <div class="status" id="status">Klicke zum Abspielen</div>

            <div class="players-guess-section" id="playersGuessSection">
                <div id="playerGuessRows"></div>
                <button class="submit-all-btn" id="submitAllBtn" onclick="submitAllGuesses()">Alle Tipps abgeben</button>
            </div>

            <div class="result" id="result">
                <div class="result-year" id="resultYear"></div>
                <div class="result-year-note" id="resultYearNote" style="display: none;"></div>
                <img class="result-artwork" id="resultArtwork" alt="Album Cover" style="display: none;">
                <div class="result-song-title" id="resultSongTitle"></div>
                <div class="result-artist-name" id="resultArtistName"></div>
                <div class="result-song-info" id="resultSongInfo" style="display: none;">
                    <div id="songInfoText"></div>
                </div>
                <div class="player-results" id="playerResults"></div>
                <div class="streaming-links">
                    <div class="streaming-label">Ganzen Song hören:</div>
                    <div class="streaming-buttons" id="streamingButtons"></div>
                </div>
                <div class="result-buttons">
                    <button class="result-btn" onclick="showStandings()">Zwischenstand</button>
                    <button class="result-btn" onclick="loadNewSong()">Nächster Song</button>
                </div>
            </div>

            <!-- Letzte Runde Overlay -->
            <div class="last-round-overlay" id="lastRoundOverlay">
                <div class="last-round-text">Letzte Runde!</div>
            </div>

            <!-- Standings Overlay -->
            <div class="standings-overlay" id="standingsOverlay">
                <div class="standings-content">
                    <div class="standings-title" id="standingsTitle">Zwischenstand</div>
                    <div class="standings-round" id="standingsRound"></div>
                    <div class="standings-list" id="standingsList"></div>
                    <div class="standings-buttons" id="standingsButtons">
                        <button class="close-standings-btn" id="standingsBtn" onclick="hideStandings()">Weiter spielen</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Genre-Popup: außerhalb gameScreen, damit es auf der Setup-Seite sichtbar ist -->
    <div class="genre-popup-overlay" id="genrePopupOverlay" onclick="if (event.target === this) hideGenrePopup();">
        <div class="genre-popup-box">
            <p class="genre-popup-text">Bitte Genre auswählen</p>
            <button class="genre-popup-btn" type="button" onclick="hideGenrePopup()">OK</button>
        </div>
    </div>

    <!-- How-it-works Modal -->
    <div class="hiw-modal-overlay" id="hiwModalOverlay" onclick="if (event.target === this) hideHowItWorksModal();">
        <div class="hiw-modal-box" role="dialog" aria-modal="true" aria-labelledby="hiwModalTitle">
            <button class="hiw-modal-close" onclick="hideHowItWorksModal()" aria-label="Schließen"><img src="buttons/Delete.svg" alt="Schließen" width="24" height="24"></button>
            <h2 class="hiw-modal-title" id="hiwModalTitle">So funktioniert's</h2>
            <ol class="hiw-steps">
                <li class="hiw-step">
                    <span class="hiw-step-number">1</span>
                    <span class="hiw-step-text"><strong>Hören:</strong> 30 Sekunden Song-Ausschnitt – ohne Titel, ohne Hinweise.</span>
                </li>
                <li class="hiw-step">
                    <span class="hiw-step-number">2</span>
                    <span class="hiw-step-text"><strong>Tippen:</strong> Schätzt das Veröffentlichungsjahr.</span>
                </li>
                <li class="hiw-step">
                    <span class="hiw-step-number">3</span>
                    <span class="hiw-step-text"><strong>Auflösung:</strong> Seht, wer am nächsten dran war – und warum der Song täuschen kann.</span>
                </li>
                <li class="hiw-step">
                    <span class="hiw-step-number">4</span>
                    <span class="hiw-step-text"><strong>Gewinnen:</strong> Am Ende zählt die geringste Gesamtabweichung.</span>
                </li>
            </ol>
            <button class="hiw-modal-btn" onclick="hideHowItWorksModal(); showSetup();">Spiel starten</button>
        </div>
    </div>

    <footer class="footer">
        powered by <a href="https://www.vais.one" target="_blank">Vertical AI Solutions</a>
    </footer>

    <audio id="audioPlayer"></audio>

    <script>
        function showSetup() {
            document.getElementById('introScreen').style.display = 'none';
            document.getElementById('setupPlayers').style.display = 'block';
            document.getElementById('wavyWrapper').classList.add('wavy-hidden');
        }

        function showSetupPlayers() {
            document.getElementById('setupOptions').style.display = 'none';
            document.getElementById('setupPlayers').style.display = 'block';
            document.getElementById('wavyWrapper').classList.add('wavy-hidden');
        }

        function showSetupOptions() {
            document.getElementById('setupPlayers').style.display = 'none';
            document.getElementById('setupOptions').style.display = 'block';
            document.getElementById('wavyWrapper').classList.add('wavy-hidden');
        }

        // How-it-works Modal
        function showHowItWorksModal() {
            const overlay = document.getElementById('hiwModalOverlay');
            overlay.classList.add('visible');
            document.body.classList.add('modal-open');
            // Focus auf ersten Button im Modal
            const closeBtn = overlay.querySelector('.hiw-modal-close');
            if (closeBtn) closeBtn.focus();
            // ESC-Listener
            document.addEventListener('keydown', hiwModalEscHandler);
        }

        function hideHowItWorksModal() {
            const overlay = document.getElementById('hiwModalOverlay');
            overlay.classList.remove('visible');
            document.body.classList.remove('modal-open');
            document.removeEventListener('keydown', hiwModalEscHandler);
            // Fokus zurück auf Trigger
            const trigger = document.getElementById('hiwTrigger');
            if (trigger) trigger.focus();
        }

        function hiwModalEscHandler(e) {
            if (e.key === 'Escape') {
                hideHowItWorksModal();
            }
        }

        /* Genre-Metadaten für UI und API. Songlisten (beginner/intermediate/expert) kommen aus fallback-genres/*.js (listsKey). */
        const genres = [
            { id: 'rock', name: 'Rock', listsKey: 'genreRockLists' },
            { id: 'pop', name: 'Pop', listsKey: 'genrePopLists' },
            { id: 'hiphop', name: 'Hip-Hop', listsKey: 'genreHiphopLists' },
            { id: 'electronic', name: 'Electronic', listsKey: 'genreElectronicLists' },
            { id: 'rnb', name: 'R&B / Soul', listsKey: 'genreRnbSoulLists' },
            { id: 'jazz', name: 'Jazz', listsKey: 'genreJazzLists' },
            { id: 'metal', name: 'Metal', listsKey: 'genreMetalLists' },
            { id: 'country', name: 'Country', listsKey: 'genreCountryLists' },
            { id: 'indie', name: 'Indie', listsKey: 'genreIndieLists' },
            { id: 'punk', name: 'Punk', listsKey: 'genrePunkLists' },
            { id: 'klassik', name: 'Klassik', listsKey: 'genreKlassikLists' },
            { id: 'techno', name: 'Techno', listsKey: 'genreTechnoLists' }
        ];

        const difficulties = [
            { id: 'beginner', name: 'Beginner' },
            { id: 'intermediate', name: 'Intermediate' },
            { id: 'expert', name: 'Expert' }
        ];

        /**
         * API-URLs: Relativ zur aktuellen Domain.
         * Voraussetzung: Webserver (nginx) leitet /api/* an den Node.js Server (Port 3001) weiter.
         */
        const OPENAI_PROXY_URL = '/api/song-info';
        const OPENAI_SUGGEST_URL = '/api/suggest-song';
        /** Spotify-Suche über den gleichen Server (Client Credentials); primäre Quelle für Song-Previews. */
        const SPOTIFY_SEARCH_URL = '/api/spotify-search';

        /** Prompt für KI-generierte Song-Erläuterung (z. B. bei API-Anbindung). */
        const SONG_INFO_PROMPT = `Erkläre kurz (maximal 3–4 Sätze), warum dieser Song zeitlich so einzuordnen ist.
Beziehe dich auf konkrete hörbare Merkmale (z. B. Drum-Sound, Synths, Vocal-Stil). Ton: musikbegeisterter Freund.
Nenne weder Songtitel noch Erscheinungsjahr – beides steht bereits darüber. Jeder Satz: etwas Hörbares oder Konkretes.`;

        /**
         * Erzeugt die Song-Info zur Auflösung je nach Schwierigkeitslevel.
         * Folgt SONG_INFO_PROMPT: konkrete hörbare Merkmale, zwei Epochen-Hinweise, warum falsch datiert, Ton: musikbegeisterter Freund.
         */
        function getSongInfoForDifficulty(artistName, trackName, releaseYear, difficulty) {
            const decade = Math.floor(releaseYear / 10) * 10;
            const decadeLabel = releaseYear < 2000 ? `${decade}er` : `${decade}`;

            if (difficulty === 'beginner') {
                return {
                    label: '',
                    text: `Der Drum-Sound und der Mix verraten die ${decadeLabel}-Jahre – der Vocal-Stil und das Arrangement passen genau in diese Phase.`
                };
            }
            if (difficulty === 'intermediate') {
                return {
                    label: '',
                    text: `Am Synth-Sound und am Arrangement hört man die ${decadeLabel}-Jahre; der Mix und die Art, wie die Stimme sitzt, sind typisch für die Zeit.`
                };
            }
            if (difficulty === 'expert') {
                return {
                    label: '',
                    text: `Drum-Sound und Wahl der Synths (oder Gitarrenverzerrung) sind zwei klare Anhaltspunkte für die ${decadeLabel}-Jahre – Arrangement und Mix bestätigen das.`
                };
            }
            return null;
        }

        /** Entfernt Klammer-/Suffix-Varianten für zuverlässige Deduplizierung (z. B. "Queen (UK)" → "queen"). */
        function normalizeForDedup(str) {
            const s = (str || '').trim().toLowerCase();
            return s.replace(/\s*\([^)]*\)\s*$/g, '').replace(/\s*-\s*topic\s*$/i, '').replace(/\s*-\s*[^-|]+$/g, '').trim();
        }
        /** Normierter Song-Key für Deduplizierung – gleicher Song trotz "Queen" vs "Queen (UK)" etc. */
        function songKey(artist, song) {
            return `${normalizeForDedup(artist)}|${normalizeForDedup(song)}`;
        }
        /** Blocklist: Vorschläge mit diesen Substrings (Artist oder Song) werden verworfen – NUR Originale, KEINE Covers. */
        const BLOCKLIST_ARTIST = [
            'chant masters', 'vitamin string quartet', 'vitamin string', 'piano guys', 'rockabye baby', 'string quartet',
            'karaoke', 'tribute band', 'cover band', 'feat.', 'featuring', 'tribute to', ' tribute ', ' cover ', ' karaoke ',
            'hit crew', 'kids bop', 'kidz bop', 'various artists', 'sounds of', 'lullaby', 'lullabies', 'rendition',
            'instrumental', 'acoustic version', 'piano version', 'orchestra version', 'reimagined', 'reimagining',
            'as made famous', 'made famous by', 'in the style of', 'style of ', 'tribute to ', 'cover of ', 'cover by ',
            'postmodern jukebox', 'scott bradlee', 'smooth jazz', 'easy listening', 'lounge '
        ];
        const BLOCKLIST_SONG = ['(feat.', '(remix)', '(remaster)', '(live)', ' feat.', ' featuring', '(cover)', '(tribute)', ' - cover', ' - tribute'];
        function isOriginalSuggestion(x) {
            if (!x || !x.artist || !x.song) return false;
            const a = (x.artist || '').toLowerCase();
            const t = (x.song || '').toLowerCase();
            if (BLOCKLIST_ARTIST.some((b) => a.includes(b))) return false;
            if (BLOCKLIST_SONG.some((b) => t.includes(b))) return false;
            return true;
        }
        /** Prüft, ob der vorgeschlagene Künstler der HAUPTKÜNSTLER im iTunes-Ergebnis ist (nur dann Original, nie Cover).
         * KRITISCH: "Nirvana Tribute Band" darf NICHT akzeptiert werden, wenn "Nirvana" gewünscht ist!
         */
        function resultArtistIsPrimary(resultArtist, wantArtist) {
            const r = (resultArtist || '').toLowerCase().trim();
            const w = (wantArtist || '').toLowerCase().trim();
            if (!w) return false;

            // Exakter Match
            if (r === w) return true;

            // Match mit "The " Präfix (z.B. "The Beatles" vs "Beatles")
            if (r === 'the ' + w || w === 'the ' + r) return true;

            // Verdächtige Suffixe, die auf Cover/Tribute hinweisen
            const suspiciousSuffixes = [
                'tribute', 'cover', 'karaoke', 'string quartet', 'orchestra',
                'ensemble', 'singers', 'choir', 'band tribute', 'tribute band',
                'project', 'experience', 'revisited', 'reimagined', 'salute',
                'celebration', 'legacy', 'memorial', 'homage'
            ];

            // Prüfe ob r mit w beginnt (z. B. "dave" aus Fallback-Phrase → "Dave Brubeck" ist ok)
            if (r.startsWith(w)) {
                const suffix = r.slice(w.length).trim();
                if (suffix === '') return true;
                // Verdächtige Suffixe (Tribute, Cover etc.) ablehnen
                if (suspiciousSuffixes.some(s => suffix.includes(s))) return false;
                // Erlaubt: "& The Heartbreakers", "feat. Someone", ", Jr." ODER weitere Künstlernamen-Teile (z. B. "Brubeck", "Brubeck Quartet")
                if (suffix.startsWith('&') || suffix.startsWith(',') ||
                    suffix.startsWith('feat') || suffix.startsWith('ft.') ||
                    suffix.startsWith('with ') || suffix.startsWith('and ')) return true;
                // Kein verdächtiges Wort im Suffix → akzeptieren (z. B. "dave" → "dave brubeck")
                return true;
            }

            // Prüfe auch "The X" Variante (z. B. "the" → "The Dave Brubeck Quartet")
            if (r.startsWith('the ' + w)) {
                const suffix = r.slice(('the ' + w).length).trim();
                if (suffix === '') return true;
                if (suspiciousSuffixes.some(s => suffix.includes(s))) return false;
                if (suffix.startsWith('&') || suffix.startsWith(',') ||
                    suffix.startsWith('feat') || suffix.startsWith('ft.')) return true;
                return true;
            }

            return false;
        }

        /** Fetch mit Timeout (vermeidet minutenlanges Warten auf Mobil). */
        const SEARCH_REQUEST_TIMEOUT_MS = 30000; // 30 Sekunden für Render Cold Start
        function fetchWithTimeout(url, options, timeoutMs) {
            const t = timeoutMs ?? SEARCH_REQUEST_TIMEOUT_MS;
            const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), t));
            return Promise.race([fetch(url, options), timeoutPromise]);
        }

        /**
         * Sucht bei der Spotify Search API (über Server-Proxy). Gibt Metadaten (artistName, trackName, releaseDate)
         * zurück; previewUrl kommt von iTunes (siehe findViaSpotifyPlayViaItunes).
         */
        async function searchSpotifyForOriginal(originalArtist, songTitle, yearMinVal, yearMaxVal) {
            const url = (SPOTIFY_SEARCH_URL || '').trim();
            if (!url) return null;
            const artist = (originalArtist || '').trim();
            const title = (songTitle || '').trim();
            if (!artist || !title) return null;
            try {
                const res = await fetchWithTimeout(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        artist,
                        song: title,
                        yearMin: yearMinVal,
                        yearMax: yearMaxVal
                    })
                }, SEARCH_REQUEST_TIMEOUT_MS);
                const data = await res.json();
                const t = data.track;
                if (!t || !t.trackName || !t.artistName) return null;
                return {
                    artistName: t.artistName,
                    trackName: t.trackName,
                    releaseDate: t.releaseDate || '',
                    previewUrl: t.previewUrl || null
                };
            } catch (e) {
                console.error('searchSpotifyForOriginal Fehler:', e.message || e);
                return null;
            }
        }

        /**
         * Findet den Song via Spotify, holt die Preview-URL von iTunes. Abspielen = iTunes-Preview.
         * WICHTIG: Anzeige und Wertung nutzen immer das Original-Erscheinungsjahr von Spotify (z. B. Kind of Blue 1959).
         * Wenn iTunes dieselbe Aufnahme als 2005 (Remaster) führt, ist das egal – es zählt das Datum der Aufnahme (Spotify).
         */
        async function findViaSpotifyPlayViaItunes(artist, songTitle, yearMinVal, yearMaxVal) {
            const spotify = await searchSpotifyForOriginal(artist, songTitle, yearMinVal, yearMaxVal);
            if (!spotify) return null;
            const itunes = await searchItunesForOriginal(spotify.artistName, spotify.trackName, null, null);
            const previewUrl = itunes?.previewUrl || spotify.previewUrl;
            if (!previewUrl) return null;
            return {
                artistName: spotify.artistName,
                trackName: spotify.trackName,
                releaseDate: spotify.releaseDate,
                previewUrl
            };
        }

        /**
         * Suchregel: Es wird NUR mit Original-Artist + Songtitel gesucht.
         * Es wird IMMER die FRÜHESTE Version (Original-Release) gewählt – nie Remaster/Re-Release (z. B. Stairway to Heaven = 1971, nicht 2005).
         * Jahr-Filter gilt nur für die Song-Vorschläge der API, nicht für die Version.
         */
        async function searchItunesForOriginal(originalArtist, songTitle, yearMinVal, yearMaxVal) {
            const artist = (originalArtist || '').trim();
            const title = (songTitle || '').trim();
            if (!artist || !title) return null;
            const searchTerm = artist + ' ' + title;
            const debug = typeof window !== 'undefined' && window.DEBUG_SUGGEST === true;
            try {
                // iTunes-Suche über Server-Proxy (umgeht CORS-Probleme auf Mobile)
                const res = await fetchWithTimeout('/api/itunes-search', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ term: searchTerm, limit: 50 })
                }, SEARCH_REQUEST_TIMEOUT_MS);
                const data = await res.json();

                if (debug) {
                    console.log('iTunes-Suche:', { searchTerm, resultsCount: data.results?.length });
                }

                const valid = (data.results || []).filter(s => {
                    if (!s.previewUrl) {
                        if (debug) console.log('  ❌ Keine Preview:', s.artistName, '-', s.trackName);
                        return false;
                    }
                    if (!isNoCover(s)) {
                        if (debug) console.log('  ❌ isNoCover failed:', s.artistName, '-', s.trackName, '| Genre:', s.primaryGenreName, '| Album:', s.collectionName);
                        return false;
                    }
                    if (!resultArtistIsPrimary(s.artistName, artist)) {
                        if (debug) console.log('  ❌ Artist mismatch:', s.artistName, '≠', artist);
                        return false;
                    }
                    return true;
                });

                if (debug) {
                    console.log('iTunes gefiltert:', valid.length, 'von', data.results?.length);
                    if (valid.length > 0) {
                        console.log('  Gültige Ergebnisse:', valid.slice(0, 5).map(s => ({
                            artist: s.artistName,
                            track: s.trackName,
                            year: new Date(s.releaseDate).getFullYear(),
                            genre: s.primaryGenreName
                        })));
                    }
                }

                if (valid.length === 0) return null;
                valid.sort((a, b) => new Date(a.releaseDate) - new Date(b.releaseDate));
                const original = valid[0];
                const year = new Date(original.releaseDate).getFullYear();

                if (yearMinVal != null && yearMaxVal != null && (year < yearMinVal || year > yearMaxVal)) {
                    if (debug) console.log('  ❌ Jahr außerhalb:', year, 'nicht in', yearMinVal, '-', yearMaxVal);
                    return null;
                }

                if (debug) console.log('  ✅ Gewählt:', original.artistName, '-', original.trackName, '(', year, ')');
                return original;
            } catch (e) {
                // Fallback: Direkte iTunes-Suche ohne Proxy (JSONP)
                console.warn('searchItunesForOriginal: Proxy fehlgeschlagen, versuche JSONP...', e.message);
                return await searchItunesDirectJSONP(artist, title, yearMinVal, yearMaxVal);
            }
        }

        /** Direkte iTunes-Suche per JSONP (funktioniert ohne Server-Proxy). */
        async function searchItunesDirectJSONP(artist, title, yearMinVal, yearMaxVal) {
            const searchTerm = (artist + ' ' + title).trim();
            if (!searchTerm) return null;
            const debug = typeof window !== 'undefined' && window.DEBUG_SUGGEST === true;

            return new Promise((resolve) => {
                const callbackName = 'itunesCallback_' + Date.now() + '_' + Math.random().toString(36).slice(2);
                const timeout = setTimeout(() => {
                    delete window[callbackName];
                    if (script.parentNode) script.parentNode.removeChild(script);
                    if (debug) console.log('  ❌ JSONP Timeout');
                    resolve(null);
                }, 10000);

                window[callbackName] = function(data) {
                    clearTimeout(timeout);
                    delete window[callbackName];
                    if (script.parentNode) script.parentNode.removeChild(script);

                    const valid = (data.results || []).filter(s => {
                        if (!s.previewUrl) return false;
                        if (!isNoCover(s)) return false;
                        if (!resultArtistIsPrimary(s.artistName, artist)) return false;
                        return true;
                    });

                    if (valid.length === 0) {
                        if (debug) console.log('  ❌ JSONP: Keine gültigen Ergebnisse');
                        resolve(null);
                        return;
                    }

                    valid.sort((a, b) => new Date(a.releaseDate) - new Date(b.releaseDate));
                    const original = valid[0];
                    const year = new Date(original.releaseDate).getFullYear();

                    if (yearMinVal != null && yearMaxVal != null && (year < yearMinVal || year > yearMaxVal)) {
                        if (debug) console.log('  ❌ JSONP Jahr außerhalb:', year);
                        resolve(null);
                        return;
                    }

                    if (debug) console.log('  ✅ JSONP Gewählt:', original.artistName, '-', original.trackName, '(', year, ')');
                    resolve(original);
                };

                const script = document.createElement('script');
                script.src = 'https://itunes.apple.com/search?term=' + encodeURIComponent(searchTerm) + '&media=music&entity=song&limit=50&callback=' + callbackName;
                document.head.appendChild(script);
            });
        }

        /** Parst eine Suchphrase in { originalArtist, songTitle }.
         * Unterstützt:
         * - Trennzeichen "|": "sex pistols | anarchy in the uk"
         * - Bekannte mehrteilige Bandnamen: "sex pistols", "dead kennedys", etc.
         * - "the X" Prefix: "the clash white riot"
         */
        function parseArtistAndTitle(phrase) {
            const t = (phrase || '').trim();

            // Format mit Trennzeichen: "artist | song"
            if (t.includes('|')) {
                const [artist, song] = t.split('|').map(s => s.trim());
                return { originalArtist: artist, songTitle: song };
            }

            // Bekannte mehrteilige Bandnamen (lowercase für Matching)
            const knownArtists = [
                'sex pistols', 'dead kennedys', 'circle jerks', 'black flag', 'minor threat',
                'bad brains', 'bad religion', 'green day', 'blink 182', 'rise against',
                'at the drive in', 'taking back sunday', 'my chemical romance', 'fall out boy',
                'joy division', 'new order', 'depeche mode', 'talking heads', 'public image ltd',
                'gang of four', 'siouxsie and the banshees', 'echo and the bunnymen',
                'the cure', 'the clash', 'the ramones', 'the damned', 'the saints',
                'the stooges', 'the velvet underground', 'the seeds', 'the troggs', 'the sonics',
                'the replacements', 'the smiths', 'the pixies', 'the strokes', 'the killers',
                'the beatles', 'the rolling stones', 'the who', 'the doors', 'the kinks',
                'led zeppelin', 'pink floyd', 'deep purple', 'black sabbath', 'iron maiden',
                'judas priest', 'motley crue', 'guns n roses', 'van halen', 'bon jovi',
                'foo fighters', 'pearl jam', 'alice in chains', 'stone temple pilots',
                'red hot chili peppers', 'rage against the machine', 'system of a down',
                'nine inch nails', 'marilyn manson', 'rob zombie', 'white zombie',
                'daft punk', 'chemical brothers', 'prodigy', 'massive attack', 'portishead',
                'boards of canada', 'aphex twin', 'autechre', 'squarepusher',
                'run dmc', 'beastie boys', 'public enemy', 'wu tang clan', 'a tribe called quest',
                'de la soul', 'cypress hill', 'outkast', 'fugees', 'lauryn hill',
                'miles davis', 'john coltrane', 'charlie parker', 'duke ellington', 'louis armstrong',
                'ella fitzgerald', 'billie holiday', 'nina simone', 'aretha franklin', 'ray charles',
                'stevie wonder', 'marvin gaye', 'al green', 'otis redding', 'sam cooke',
                'fleetwood mac', 'crosby stills nash', 'simon and garfunkel', 'hall and oates',
                'tears for fears', 'duran duran', 'spandau ballet', 'simple minds', 'ultravox',
                'hot water music', 'against me', 'gaslight anthem', 'hold steady', 'jawbreaker',
                'husker du', 'dinosaur jr', 'sonic youth', 'pixies', 'pavement',
                'guided by voices', 'built to spill', 'modest mouse', 'death cab for cutie',
                'arcade fire', 'lcd soundsystem', 'vampire weekend', 'mgmt', 'tame impala',
                'king gizzard', 'arctic monkeys', 'franz ferdinand', 'bloc party', 'interpol',
                'queens of the stone age', 'them crooked vultures', 'royal blood', 'highly suspect',
                'soft play', 'amyl and the sniffers', 'fontaines dc', 'idles', 'shame', 'sleaford mods'
            ];

            const lowerPhrase = t.toLowerCase();
            for (const artist of knownArtists) {
                if (lowerPhrase.startsWith(artist + ' ')) {
                    const songTitle = t.slice(artist.length).trim();
                    // Originalschreibweise aus der Phrase extrahieren
                    const originalArtist = t.slice(0, artist.length);
                    return { originalArtist, songTitle };
                }
            }

            // Fallback: Alte Logik für unbekannte Artists
            const parts = t.split(/\s+/).filter(Boolean);
            if (parts.length < 2) return { originalArtist: '', songTitle: '' };
            if (parts[0].toLowerCase() === 'the' && parts.length >= 3)
                return { originalArtist: parts[0] + ' ' + parts[1], songTitle: parts.slice(2).join(' ') };
            return { originalArtist: parts[0], songTitle: parts.slice(1).join(' ') };
        }

        /** Prüft: Nur ORIGINAL – kein Cover, Tribute, Karaoke, Remix, Live, feat. usw.
         * Prüft: Artist, Track, Album UND iTunes-spezifische Metadaten (primaryGenreName, collectionType, kind).
         */
        function isNoCover(s) {
            const trackLower = (s.trackName || '').toLowerCase();
            const albumLower = (s.collectionName || '').toLowerCase();
            const artistLower = (s.artistName || '').toLowerCase();
            const combined = trackLower + ' ' + albumLower + ' ' + artistLower;

            // NEU: iTunes-spezifische Metadaten prüfen
            const genre = (s.primaryGenreName || '').toLowerCase();
            const badGenres = ['karaoke', 'tribute', "children's music", 'children', 'lullaby',
                'lullabies', 'easy listening', 'spoken word', 'audiobook', 'podcast'];
            if (badGenres.some(g => genre.includes(g))) return false;

            // Compilation-Alben sind oft Tribute/Cover-Sammlungen
            if (s.collectionType === 'Compilation') return false;

            // Nur echte Songs, keine Videos oder andere Medientypen
            if (s.kind && s.kind !== 'song') return false;

            // Bekannte Cover-Interpreten und verdächtige Artist-Namen
            const coverArtistTerms = [
                'chant masters', 'vitamin string quartet', 'vitamin string', 'piano guys',
                'rockabye baby', 'string quartet', 'karaoke', 'tribute band', 'cover band',
                ' tribute ', ' cover ', ' karaoke ', 'hit crew', 'kids bop', 'kidz bop',
                'various artists', 'sounds of', 'lullaby', 'lullabies', 'rendition',
                'instrumental', 'acoustic version', 'piano version', 'orchestra version',
                'reimagined', 'reimagining', 'as made famous', 'made famous by',
                'in the style of', 'style of ', 'tribute to ', 'cover of ', 'cover by ',
                ' feat.', 'featuring', 'postmodern jukebox', 'scott bradlee', 'smooth jazz',
                'easy listening', 'lounge ', 'midnite string', 'london symphony tribute',
                'punk rock factory', 'gregorian', 'scala ', 'northern kings',
                'symphonic rock', 'metal tribute', 'rock tribute'
            ];
            if (coverArtistTerms.some((t) => artistLower.includes(t))) return false;

            // NEU: Artist-Name enthält verdächtige Wörter (z.B. "Nirvana Tribute Band")
            // ACHTUNG: "experience" NICHT blocken - "Jimi Hendrix Experience" ist legitim!
            const artistSuspiciousWords = ['tribute', 'karaoke', ' cover ', 'salute to', 'revisited',
                'reimagined', ' legacy', 'celebration of', 'memorial'];
            if (artistSuspiciousWords.some(w => artistLower.includes(w))) return false;

            // Live, Remaster, Remix, Extended etc.
            // ACHTUNG: "live" als Wort, nicht als Substring (sonst "Alive", "Oliver" etc. geblockt)
            // Remaster/Reissue nur im TRACK ablehnen – Album darf "(Remastered)" haben (Jazz/Klassik oft nur so bei iTunes)
            if (combined.includes(' live ') || combined.includes('(live)') || combined.includes('(live ') ||
                combined.includes(' - live') || combined.includes(' live)') ||
                trackLower.startsWith('live ') || trackLower.endsWith(' live') ||
                combined.includes('live at ') || combined.includes('live in ') ||
                combined.includes('concert') || combined.includes('wembley') || combined.includes('woodstock') ||
                combined.includes('unplugged') ||
                trackLower.includes('remaster') || combined.includes('remix') ||
                combined.includes(' mix)') || combined.includes(' (mix)') || combined.includes(' mix ') ||
                trackLower.endsWith(' mix') || trackLower.includes('(feat.') || trackLower.includes(' feat.') ||
                trackLower.includes('(featuring') || trackLower.includes(' featuring') ||
                trackLower.includes('deluxe edition') || trackLower.includes('anniversary edition') ||
                trackLower.includes('reissue') || trackLower.includes('re-record')) return false;

            if (/\d{2,4}\s*th\s*(anniversary|year)/.test(combined) || /take\s*\d+/.test(combined)) return false;

            // Demos, Outtakes, Sessions
            if (combined.includes('outtake') || combined.includes(' demo') || combined.includes('(demo)') ||
                combined.includes('alternate') || combined.includes('session') ||
                combined.includes('previously unreleased') || combined.includes('unreleased')) return false;

            // Cover-Indikatoren
            if (combined.includes('(cover)') || combined.includes('cover version') ||
                combined.includes('cover of') || combined.includes('cover by') ||
                combined.includes('covered by') || combined.includes(' - cover') ||
                combined.includes(' - tribute') || combined.includes('reimagined') ||
                combined.includes('reimagining') || combined.includes('in the style of') ||
                combined.includes('as made famous') || combined.includes('made famous by')) return false;

            // Album-spezifische Prüfungen (NICHT "greatest hits", "best of" - Originale sind oft auf Best-Of-Alben!)
            // "instrumental" weggelassen – Jazz-Alben heißen oft "… Instrumental" und sind Originale
            if (albumLower.includes(' covers') || albumLower.includes('covers ') ||
                albumLower.includes('tribute') || albumLower.includes('karaoke') ||
                albumLower.includes('lullaby')) return false;

            // Soundtrack/Film (oft Re-Recordings oder Covers)
            if (combined.includes('movie') || combined.includes('motion picture') ||
                combined.includes('from the film') || combined.includes('from the motion picture') ||
                trackLower.includes(' clip') || combined.includes('soundtrack')) return false;

            return true;
        }

        /** Entfernt Dubletten aus einer Liste von { artist, song } (gleicher Artist + Titel nur einmal). */
        function dedupeSongList(list) {
            const seen = new Set();
            return (list || []).filter((x) => {
                if (!x || !x.artist || !x.song) return false;
                const key = songKey(x.artist, x.song);
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
        }

        /** Mischt ein Array zufällig (Fisher-Yates), damit nicht bei jedem Spiel dieselbe Reihenfolge kommt. */
        function shuffleArray(arr) {
            const a = (arr || []).slice();
            for (let i = a.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [a[i], a[j]] = [a[j], a[i]];
            }
            return a;
        }

        /** Lade-Meldungen: Satz für Satz mit 2 Sekunden Pause. */
        const LOADING_MESSAGES = [
            'Am Anfang dauert es einen kleinen Moment.',
            'Wir bereiten alles für euch vor.',
            'Die Songs werden ausgewählt.',
            'Die passenden Ausschnitte werden geladen.',
            'Ein paar Dinge sortieren sich im Hintergrund.',
            'Das passiert nur einmal.',
            'Danach geht es schneller.',
            'Deutlich schneller.',
            'Ein Song folgt dem nächsten.',
            'Ohne lange Pausen.',
            'Ihr müsst nichts weiter tun.',
            'Nur kurz warten.',
            'Dann geht es los.',
            'Gleich.'
        ];
        const SENTENCE_PAUSE_MS = 2000;

        /** Einfache Ladeanimation die auf allen Geräten funktioniert */
        function startLoadingStatus(statusEl, isFirstLoad = true) {
            if (!statusEl) return null;
            statusEl.classList.add('status-loading');
            const handle = { intervalId: null, dotIntervalId: null };

            if (!isFirstLoad) {
                statusEl.textContent = 'Weiter geht\'s';
                return handle;
            }

            let msgIndex = 0;
            let dots = 0;
            const baseText = LOADING_MESSAGES[msgIndex];
            statusEl.textContent = baseText;

            // Pulsierende Punkte alle 400ms
            handle.dotIntervalId = setInterval(() => {
                if (!statusEl.classList.contains('status-loading')) return;
                dots = (dots + 1) % 4;
                const currentBase = LOADING_MESSAGES[msgIndex] || LOADING_MESSAGES[0];
                statusEl.textContent = currentBase + '.'.repeat(dots);
            }, 400);

            // Text wechseln alle 2 Sekunden
            handle.intervalId = setInterval(() => {
                if (!statusEl.classList.contains('status-loading')) return;
                msgIndex += 1;
                if (msgIndex >= LOADING_MESSAGES.length) {
                    msgIndex = 0; // Loop zurück zum Anfang
                }
                dots = 0;
                statusEl.textContent = LOADING_MESSAGES[msgIndex];
            }, SENTENCE_PAUSE_MS);

            return handle;
        }
        function stopLoadingStatus(statusEl, handle) {
            if (handle != null) {
                if (handle.intervalId != null) clearInterval(handle.intervalId);
                if (handle.dotIntervalId != null) clearInterval(handle.dotIntervalId);
            }
            if (statusEl) {
                statusEl.classList.remove('status-loading', 'fade-in');
            }
        }
        /** Debug-Modus: ?debug=1 an URL anhängen für sichtbare Fehleranzeige */
        const DEBUG_MODE = new URLSearchParams(window.location.search).get('debug') === '1';
        if (DEBUG_MODE) {
            window.DEBUG_SUGGEST = true;
            const debugBox = document.createElement('div');
            debugBox.id = 'debugBox';
            debugBox.style.cssText = 'position:fixed;bottom:0;left:0;right:0;max-height:40vh;overflow:auto;background:#111;color:#0f0;font-family:monospace;font-size:12px;padding:10px;z-index:9999;';
            document.body.appendChild(debugBox);
            const origConsole = { log: console.log, error: console.error, warn: console.warn };
            const addDebug = (type, args) => {
                const line = document.createElement('div');
                line.style.color = type === 'error' ? '#f66' : type === 'warn' ? '#ff0' : '#0f0';
                line.textContent = `[${type}] ${Array.from(args).map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ')}`;
                debugBox.appendChild(line);
                debugBox.scrollTop = debugBox.scrollHeight;
            };
            console.log = (...args) => { origConsole.log(...args); addDebug('log', args); };
            console.error = (...args) => { origConsole.error(...args); addDebug('error', args); };
            console.warn = (...args) => { origConsole.warn(...args); addDebug('warn', args); };
            window.onerror = (msg, src, line, col, err) => addDebug('error', [`${msg} at ${src}:${line}:${col}`]);
            console.log('Debug-Modus aktiv');
        }
        /** Debug: In der Konsole `window.DEBUG_SUGGEST = true` setzen, dann „Spiel starten" – Request/Response erscheinen in der Konsole. */
        /** Holt eine Liste von Song-Vorschlägen von der API (Kuratoren-Prompt). Gibt Array von { artist, song } oder []. */
        async function fetchSuggestSongList(genreNames, difficulty, yearMinVal, yearMaxVal, count = 12) {
            const debug = typeof window !== 'undefined' && window.DEBUG_SUGGEST === true;
            const url = (OPENAI_SUGGEST_URL || '').trim();
            if (!url) {
                if (debug) console.warn('Suggest-Song: Keine OPENAI_SUGGEST_URL gesetzt.');
                return [];
            }
            const body = { genres: genreNames, difficulty, yearMin: yearMinVal, yearMax: yearMaxVal, count };
            if (debug) console.log('Suggest-Song Request:', { url, body });
            try {
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const data = await res.json();
                if (debug) console.log('Suggest-Song Response:', { ok: res.ok, status: res.status, data });
                if (!res.ok) return [];
                const list = Array.isArray(data.songs) ? data.songs : [];
                const normalized = list.filter((x) => x && x.artist && x.song).map((x) => ({ artist: String(x.artist).trim(), song: String(x.song).trim() }));
                const originalsOnly = normalized.filter(isOriginalSuggestion);
                const out = dedupeSongList(originalsOnly);
                if (debug) console.log('Suggest-Song nach Filter/Dedup:', out.length, out);
                return out;
            } catch (e) {
                console.error('Suggest-SongList:', e);
                return [];
            }
        }

        /** Holt Song-Erklärung von OpenAI über Proxy (GPT-4.1 mini). Gibt null bei Fehler oder fehlendem Proxy. */
        async function fetchSongInfoFromOpenAI(artistName, trackName, releaseYear) {
            const proxyUrl = (OPENAI_PROXY_URL || '').trim();
            if (!proxyUrl) return null;

            const userContent = `${SONG_INFO_PROMPT}

(Kontext für dich: Song „${trackName}" von ${artistName}, Erscheinungsjahr ${releaseYear})

Antworte nur mit dem Erklärungstext. Keine Überschrift, keine Nennung von Songtitel oder Jahr – das steht schon darüber.`;

            try {
                const res = await fetch(proxyUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        artistName,
                        trackName,
                        releaseYear,
                        prompt: SONG_INFO_PROMPT,
                        userContent
                    })
                });
                if (!res.ok) throw new Error(res.statusText);
                const data = await res.json();
                if (data.error) throw new Error(data.error);
                return (data.text || data.content || '').trim();
            } catch (e) {
                console.warn('Song-Erklärung: API nicht erreichbar (Server läuft? OPENAI_PROXY_URL?) – Fallback-Erklärung wird angezeigt.', e.message || e);
                return null;
            }
        }

        /** Erklärung mit Timeout laden (z. B. für ersten Song / Preload). Gibt Text oder null. */
        async function fetchSongInfoWithTimeout(artistName, trackName, releaseYear, timeoutMs = 35000) {
            try {
                const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), timeoutMs));
                const text = await Promise.race([fetchSongInfoFromOpenAI(artistName, trackName, releaseYear), timeoutPromise]);
                return (text && String(text).trim()) ? text.trim() : null;
            } catch (e) {
                if (e.message === 'Timeout') console.warn('Song-Erklärung: Timeout nach', timeoutMs, 'ms');
                return null;
            }
        }

        /** Fallback-Erklärungstext (Epoche/Kurzfassung), wenn API fehlschlägt. */
        function getFallbackExplanationText(artistName, trackName, releaseYear) {
            const fb = getSongInfoForDifficulty(artistName, trackName, releaseYear, selectedDifficulty);
            return (fb && fb.text) ? fb.text : 'Der Drum-Sound und der Mix verraten die Epoche – typisch für die Zeit.';
        }

        const currentYear = new Date().getFullYear();
        let playerCount = 2;
        let totalRounds = 5;
        let players = [];
        let selectedGenres = new Set(['rock', 'pop', 'indie']);
        let selectedDifficulty = 'beginner';
        let yearMin = 1940;
        let yearMax = currentYear;
        let currentSong = null;
        /** Promise für die Song-Erklärung – wird beim Laden des Songs gestartet, damit sie beim Abgeben der Tipps oft schon da ist. */
        let songInfoPromise = null;

        /** Bekannte falsche Release-Jahre (Spotify/iTunes) → korrektes Jahr. Key: "artist|titel" normalisiert (klein, Leerzeichen 1). */
        const RELEASE_YEAR_OVERRIDES = {
            'pharoah sanders|the creator has a master plan': 1969,
            'glenn miller|in the mood': 1940
        };
        function applyReleaseYearOverride(song) {
            if (!song || !song.artistName || !song.trackName) return;
            const key = (song.artistName + '|' + song.trackName).toLowerCase().replace(/\s+/g, ' ').trim();
            const year = RELEASE_YEAR_OVERRIDES[key];
            if (year != null) song.releaseDate = year + '-01-01';
        }
        let guessSubmitted = false;
        let roundNumber = 0;
        let songQueue = [];
        /** Bereits in dieser Runde gespielte Songs (Keys), damit beim Nachladen keine Dubletten kommen. */
        let playedSongKeys = new Set();
        /** Vor geladene Songs inkl. Erklärung: [{ song, explanation }], max 3. */
        let preloadedSongs = [];
        let preloadInProgress = false;

        const PREVIEW_DURATION_SEC = 30;
        const PLAY_COUNTDOWN_CIRCUMFERENCE = 2 * Math.PI * 47;
        let playCountdownIntervalId = null;

        function setPlayButtonDisplay(iconType) {
            const playBtn = document.getElementById('playBtn');
            const playIcon = playBtn?.querySelector('.play-icon');
            const pauseIcon = playBtn?.querySelector('.pause-icon');
            const countdown = document.getElementById('playBtnCountdown');
            if (countdown) countdown.textContent = '';

            if (iconType === 'pause' || iconType === 'II') {
                if (playIcon) playIcon.style.display = 'none';
                if (pauseIcon) pauseIcon.style.display = 'inline-block';
            } else if (iconType === 'play' || iconType === '▶') {
                if (playIcon) playIcon.style.display = 'inline-block';
                if (pauseIcon) pauseIcon.style.display = 'none';
            } else if (iconType === '' || iconType === '?') {
                // Loading or unknown state - hide both
                if (playIcon) playIcon.style.display = iconType === '?' ? 'inline-block' : 'none';
                if (pauseIcon) pauseIcon.style.display = 'none';
            } else {
                // Default: show play
                if (playIcon) playIcon.style.display = 'inline-block';
                if (pauseIcon) pauseIcon.style.display = 'none';
            }
        }
        function resetPlayCountdown() {
            if (playCountdownIntervalId) {
                clearInterval(playCountdownIntervalId);
                playCountdownIntervalId = null;
            }
            const ring = document.getElementById('playCountdownRing');
            if (ring) ring.setAttribute('stroke-dashoffset', '0');
            const playBtn = document.getElementById('playBtn');
            if (playBtn) playBtn.classList.remove('playing');
        }
        function updatePlayCountdown() {
            const audio = document.getElementById('audioPlayer');
            if (!audio || audio.paused) return;
            const elapsed = Math.min(audio.currentTime, PREVIEW_DURATION_SEC);
            const ring = document.getElementById('playCountdownRing');
            if (ring) ring.setAttribute('stroke-dashoffset', -((elapsed / PREVIEW_DURATION_SEC) * PLAY_COUNTDOWN_CIRCUMFERENCE) + '');
            const countdownEl = document.getElementById('playBtnCountdown');
            if (countdownEl) countdownEl.textContent = Math.max(0, Math.ceil(PREVIEW_DURATION_SEC - elapsed));
        }

        function init() {
            renderPlayerCount();
            renderPlayerInputs();
            renderRoundCount();
            renderGenres();
            renderDifficulty();
            setupRangeSlider();
            updateStartButton();
        }

        function renderPlayerCount() {
            const container = document.getElementById('playerCount');
            container.innerHTML = [1,2,3,4,5,6].map(n => `
                <button class="player-count-btn ${n === playerCount ? 'selected' : ''}" onclick="setPlayerCount(${n})">${n}</button>
            `).join('');
        }

        function setPlayerCount(n) {
            playerCount = n;
            renderPlayerCount();
            renderPlayerInputs();
            updateStartButton();
        }

        function renderPlayerInputs() {
            const container = document.getElementById('playerInputs');
            container.innerHTML = Array.from({length: playerCount}, (_, i) => `
                <input type="text" class="player-name-input" placeholder="Spieler ${i+1}" data-index="${i}" maxlength="20">
            `).join('');
        }

        function renderRoundCount() {
            const container = document.getElementById('roundCount');
            container.innerHTML = [5, 10, 15].map(n => `
                <button class="round-count-btn ${n === totalRounds ? 'selected' : ''}" onclick="setRoundCount(${n})">${n}</button>
            `).join('');
        }

        function setRoundCount(n) {
            totalRounds = n;
            renderRoundCount();
        }

        function renderGenres() {
            const grid = document.getElementById('genreGrid');
            grid.innerHTML = genres.map(g => `
                <div class="genre-item ${selectedGenres.has(g.id) ? 'selected' : ''}" data-genre="${g.id}">
                    <span class="genre-checkbox"></span>
                    <span class="genre-name">${g.name}</span>
                </div>
            `).join('');

            grid.querySelectorAll('.genre-item').forEach(item => {
                item.addEventListener('click', () => {
                    const id = item.dataset.genre;
                    if (selectedGenres.has(id)) {
                        selectedGenres.delete(id);
                        item.classList.remove('selected');
                    } else {
                        selectedGenres.add(id);
                        item.classList.add('selected');
                    }
                    updateStartButton();
                });
            });
        }

        function renderDifficulty() {
            const container = document.getElementById('difficultyButtons');
            container.innerHTML = difficulties.map(d => `
                <button class="difficulty-btn ${d.id === selectedDifficulty ? 'selected' : ''}" onclick="setDifficulty('${d.id}')">${d.name}</button>
            `).join('');
        }

        function setDifficulty(id) {
            selectedDifficulty = id;
            renderDifficulty();
        }

        function setupRangeSlider() {
            const rangeMin = document.getElementById('rangeMin');
            const rangeMax = document.getElementById('rangeMax');
            rangeMin.max = rangeMax.max = currentYear;
            rangeMax.value = currentYear;
            document.getElementById('yearMax').textContent = currentYear;

            function update() {
                let min = parseInt(rangeMin.value);
                let max = parseInt(rangeMax.value);
                if (min > max - 5) {
                    if (this === rangeMin) { min = max - 5; rangeMin.value = min; }
                    else { max = min + 5; rangeMax.value = max; }
                }
                yearMin = min; yearMax = max;
                document.getElementById('yearMin').textContent = min;
                document.getElementById('yearMax').textContent = max;
                const minP = ((min - 1940) / (currentYear - 1940)) * 100;
                const maxP = ((max - 1940) / (currentYear - 1940)) * 100;
                document.getElementById('sliderRange').style.left = minP + '%';
                document.getElementById('sliderRange').style.width = (maxP - minP) + '%';
            }
            rangeMin.addEventListener('input', update);
            rangeMax.addEventListener('input', update);
            update.call(rangeMin);
        }

        function updateStartButton() {
            // Button bleibt klickbar; bei 0 Genres zeigt startGame() das Popup "Bitte Genre auswählen"
        }

        /** Flag: Hintergrund-Ladevorgang für Songliste aktiv */
        let backgroundFetchInProgress = false;

        function showGenrePopup() {
            document.getElementById('genrePopupOverlay').classList.add('visible');
        }
        function hideGenrePopup() {
            document.getElementById('genrePopupOverlay').classList.remove('visible');
        }

        /** Genre-ID → Skriptdateiname (ohne Pfad/Endung) für Fallback-Daten. Nur bei Bedarf laden. */
        const FALLBACK_SCRIPT_BY_GENRE = {
            rock: 'rock', pop: 'pop', hiphop: 'hiphop', electronic: 'electronic',
            rnb: 'rnb-soul', country: 'country', klassik: 'klassik', punk: 'punk',
            indie: 'indie', jazz: 'jazz', techno: 'techno', metal: 'metal'
        };
        const loadedFallbackGenres = new Set();
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = src;
                s.onload = () => resolve();
                s.onerror = () => reject(new Error('Fallback-Skript fehlgeschlagen: ' + src));
                document.head.appendChild(s);
            });
        }
        async function loadFallbackScripts(genreIds) {
            const toLoad = genreIds
                .map(id => FALLBACK_SCRIPT_BY_GENRE[id])
                .filter(Boolean)
                .filter(file => !loadedFallbackGenres.has(file));
            for (const f of toLoad) {
                try {
                    await loadScript('fallback-genres/' + f + '.js');
                    loadedFallbackGenres.add(f);
                } catch (e) {
                    console.warn('Fallback-Skript nicht geladen:', f, e.message);
                }
                await new Promise(r => setTimeout(r, 0));
            }
        }

        /** Kurz dem Browser Zeit geben, die UI zu zeichnen (vermeidet Hänger auf Mobil). */
        function yieldToPaint() {
            return new Promise(resolve => setTimeout(resolve, 150));
        }

        async function startGame() {
            if (selectedGenres.size === 0) {
                showGenrePopup();
                return;
            }
            const statusEl = document.getElementById('status');
            const playBtnStart = document.getElementById('playBtn');
            let loadingId = null;
            try {
                players = [];
                document.querySelectorAll('.player-name-input').forEach((input, i) => {
                    players.push({ name: input.value.trim() || `Spieler ${i+1}`, guess: null, totalDiff: 0 });
                });
                roundNumber = 0;
                songQueue = [];
                playedSongKeys = new Set();
                preloadedSongs = [];

                document.getElementById('setupOptions').style.display = 'none';
                document.getElementById('gameScreen').classList.add('visible');
                renderPlayerGuessRows();
                
                // Animation einblenden (unteres Drittel auf Mobile)
                document.getElementById('wavyWrapper').classList.remove('wavy-hidden');

                playBtnStart.disabled = true;
                setPlayButtonDisplay('');
                playBtnStart.classList.add('loading');
                resetPlayCountdown();
                loadingId = startLoadingStatus(statusEl);

                await yieldToPaint();

                await loadFallbackScripts(Array.from(selectedGenres));

                const genreNames = genres.filter((g) => selectedGenres.has(g.id)).map((g) => g.name);
                if (genreNames.length && OPENAI_SUGGEST_URL) {
                    try {
                        const apiPromise = fetchSuggestSongList(genreNames, selectedDifficulty, yearMin, yearMax, 12);
                        const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 30000));
                        const list = await Promise.race([apiPromise, timeoutPromise]);
                        if (list.length) {
                            songQueue = shuffleArray(dedupeSongList(list));
                            if (window.DEBUG_SUGGEST) console.log('API-Songliste geladen:', songQueue.length, 'Songs');
                        }
                    } catch (e) {
                        console.warn('API-Fetch fehlgeschlagen oder Timeout, nutze Fallback:', e.message);
                    } finally {
                        stopLoadingStatus(statusEl, loadingId);
                        loadingId = null;
                    }
                } else {
                    stopLoadingStatus(statusEl, loadingId);
                    loadingId = null;
                }

                statusEl.textContent = '';
                await loadNewSong(true);

                // Wavy Background nach Laden ausblenden (Mobile)
                document.getElementById('wavyWrapper').classList.add('wavy-hidden');
            } catch (e) {
                console.error('startGame:', e);
                if (loadingId) stopLoadingStatus(statusEl, loadingId);
                playBtnStart.disabled = false;
                playBtnStart.classList.remove('loading');
                setPlayButtonDisplay('▶');
                resetPlayCountdown();
                statusEl.textContent = 'Fehler. Bitte Seite neu laden oder später erneut versuchen.';
                // Wavy Background auch bei Fehler ausblenden
                document.getElementById('wavyWrapper').classList.add('wavy-hidden');
            }
        }

        function renderPlayerGuessRows() {
            const container = document.getElementById('playerGuessRows');
            container.innerHTML = players.map((p, i) => `
                <div class="player-guess-row">
                    <span class="player-guess-name">${p.name}</span>
                    <input type="password" class="player-guess-input" data-player="${i}" maxlength="4" placeholder="Jahr" inputmode="numeric" autocomplete="one-time-code" data-lpignore="true" data-1p-ignore>
                </div>
            `).join('');

            container.querySelectorAll('.player-guess-input').forEach(input => {
                input.addEventListener('input', e => {
                    e.target.value = e.target.value.replace(/[^0-9]/g, '');
                });
            });
        }

        function backToSetup() {
            document.getElementById('audioPlayer').pause();
            document.getElementById('gameScreen').classList.remove('visible');
            document.getElementById('setupOptions').style.display = 'block';
            document.getElementById('result').classList.remove('visible');
            document.getElementById('playersGuessSection').classList.remove('visible');
            document.getElementById('wavyWrapper').classList.add('wavy-hidden');
        }

        /** Lädt im Hintergrund bis zu 3 Songs inkl. Erklärung in preloadedSongs (nur aus songQueue). */
        async function preloadNextSongs() {
            if (preloadInProgress || preloadedSongs.length >= 3 || songQueue.length === 0) return;
            preloadInProgress = true;
            const targetCount = 3;
            try {
                while (preloadedSongs.length < targetCount && songQueue.length > 0) {
                    const suggestion = songQueue[0];
                    const wantArtist = (suggestion?.artist || '').trim();
                    const wantSong = (suggestion?.song || '').trim();
                    if (!wantArtist || !wantSong) {
                        songQueue.splice(0, 1);
                        continue;
                    }
                    let found = await findViaSpotifyPlayViaItunes(wantArtist, wantSong, yearMin, yearMax);
                    if (!found) found = await searchItunesForOriginal(wantArtist, wantSong, yearMin, yearMax);
                    if (!found) {
                        songQueue.splice(0, 1);
                        continue;
                    }
                    applyReleaseYearOverride(found);
                    const year = new Date(found.releaseDate).getFullYear();
                    const explanation = await fetchSongInfoWithTimeout(found.artistName, found.trackName, year, 35000);
                    const text = (explanation && explanation.trim()) ? explanation.trim() : getFallbackExplanationText(found.artistName, found.trackName, year);
                    preloadedSongs.push({ song: found, explanation: text });
                    songQueue.splice(0, 1);
                }
            } catch (e) {
                console.warn('Preload fehlgeschlagen:', e);
            } finally {
                preloadInProgress = false;
            }
        }

        async function loadNewSong(waitForFirstExplanation = false) {
            if (DEBUG_MODE) console.log('loadNewSong gestartet, waitForFirstExplanation:', waitForFirstExplanation);

            // "Letzte Runde!" Overlay anzeigen
            if (roundNumber + 1 === totalRounds && roundNumber > 0) {
                const overlay = document.getElementById('lastRoundOverlay');
                overlay.classList.add('visible');
                await new Promise(resolve => setTimeout(resolve, 2000));
                overlay.classList.add('fade-out');
                await new Promise(resolve => setTimeout(resolve, 500));
                overlay.classList.remove('visible', 'fade-out');
            }

            guessSubmitted = false;
            currentSong = null;
            songInfoPromise = null;
            document.getElementById('roundCounter').textContent = '';
            const playBtn = document.getElementById('playBtn');
            const status = document.getElementById('status');
            playBtn.disabled = true;
            setPlayButtonDisplay('');
            playBtn.classList.add('loading');
            resetPlayCountdown();
            document.getElementById('playersGuessSection').classList.remove('visible');
            document.getElementById('result').classList.remove('visible');
            document.getElementById('submitAllBtn').disabled = false;
            const loadingId = startLoadingStatus(status, waitForFirstExplanation);
            document.getElementById('audioPlayer').pause();

            // Reset inputs
            document.querySelectorAll('.player-guess-input').forEach(input => {
                input.value = '';
                input.type = 'password';
                input.classList.remove('submitted', 'revealed');
                input.disabled = false;
            });
            players.forEach(p => p.guess = null);

            // Vor geladene Songs nutzen (Erklärung ist schon da)
            if (!waitForFirstExplanation && preloadedSongs.length > 0) {
                const entry = preloadedSongs.shift();
                currentSong = entry.song;
                applyReleaseYearOverride(currentSong);
                songInfoPromise = Promise.resolve(entry.explanation);
                playedSongKeys.add(songKey(currentSong.artistName, currentSong.trackName));
                document.getElementById('audioPlayer').src = currentSong.previewUrl;
                playBtn.disabled = false;
                playBtn.classList.remove('loading');
                setPlayButtonDisplay('▶');
                resetPlayCountdown();
                stopLoadingStatus(status, loadingId);
                status.textContent = waitForFirstExplanation ? 'Klicke zum Abspielen' : 'Weiter geht\'s';
                document.getElementById('roundCounter').textContent = `Runde ${roundNumber + 1} / ${totalRounds}`;
                preloadNextSongs();
                return;
            }

            // Nachladen im Hintergrund wenn Queue fast leer (nicht blockierend!)
            if (songQueue.length < 3 && OPENAI_SUGGEST_URL && !backgroundFetchInProgress) {
                const genreNames = genres.filter((g) => selectedGenres.has(g.id)).map((g) => g.name);
                if (genreNames.length) {
                    backgroundFetchInProgress = true;
                    fetchSuggestSongList(genreNames, selectedDifficulty, yearMin, yearMax, 12)
                        .then(list => {
                            const withoutPlayed = list.filter((x) => !playedSongKeys.has(songKey(x.artist, x.song)));
                            const newSongs = dedupeSongList(withoutPlayed);
                            songQueue.push(...newSongs);
                            songQueue = shuffleArray(songQueue);
                            if (window.DEBUG_SUGGEST) console.log('Nachgeladen:', newSongs.length, 'Songs');
                        })
                        .catch(e => console.error('Nachladen fehlgeschlagen:', e))
                        .finally(() => { backgroundFetchInProgress = false; });
                }
            }

            for (let i = 0; i < songQueue.length; i++) {
                const suggestion = songQueue[i];
                const wantArtist = (suggestion?.artist || '').trim();
                const wantSong = (suggestion?.song || '').trim();
                if (!wantArtist || !wantSong) continue;
                let found = await findViaSpotifyPlayViaItunes(wantArtist, wantSong, yearMin, yearMax);
                if (!found) found = await searchItunesForOriginal(wantArtist, wantSong, yearMin, yearMax);
                if (found) {
                    currentSong = found;
                    applyReleaseYearOverride(currentSong);
                    const year = new Date(currentSong.releaseDate).getFullYear();
                    if (waitForFirstExplanation) {
                        const explanation = await fetchSongInfoWithTimeout(currentSong.artistName, currentSong.trackName, year, 35000);
                        songInfoPromise = Promise.resolve((explanation && explanation.trim()) ? explanation.trim() : getFallbackExplanationText(currentSong.artistName, currentSong.trackName, year));
                    } else {
                        songInfoPromise = fetchSongInfoFromOpenAI(currentSong.artistName, currentSong.trackName, year);
                    }
                    playedSongKeys.add(songKey(wantArtist, wantSong));
                    songQueue.splice(i, 1);
                    document.getElementById('audioPlayer').src = currentSong.previewUrl;
                    playBtn.disabled = false;
                    playBtn.classList.remove('loading');
                    setPlayButtonDisplay('▶');
                    resetPlayCountdown();
                    stopLoadingStatus(status, loadingId);
                    status.textContent = waitForFirstExplanation ? 'Klicke zum Abspielen' : 'Weiter geht\'s';
                    document.getElementById('roundCounter').textContent = `Runde ${roundNumber + 1} / ${totalRounds}`;
                    if (waitForFirstExplanation) preloadNextSongs();
                    return;
                }
            }

            try {
                await yieldToPaint();
            } catch (e) {
                console.warn('yieldToPaint:', e);
            }
            const queries = [];
            genres.forEach(g => {
                if (!selectedGenres.has(g.id)) return;
                const lists = window[g.listsKey];
                if (lists && Array.isArray(lists[selectedDifficulty])) queries.push(...lists[selectedDifficulty]);
            });
            // Zusätzlich: Genre-Subgenres als Fallback (Daten aus fallback-genres/*.js, bei Bedarf geladen)
            if (selectedGenres.has('rock') && typeof fallbackRockSubgenres === 'object') {
                Object.values(fallbackRockSubgenres).forEach(arr => {
                    if (Array.isArray(arr)) queries.push(...arr);
                });
            }
            if (selectedGenres.has('pop') && typeof fallbackPopSubgenres === 'object') {
                Object.values(fallbackPopSubgenres).forEach(arr => {
                    if (Array.isArray(arr)) queries.push(...arr);
                });
            }
            if (selectedGenres.has('hiphop') && typeof fallbackHiphopSubgenres === 'object') {
                Object.values(fallbackHiphopSubgenres).forEach(arr => {
                    if (Array.isArray(arr)) queries.push(...arr);
                });
            }
            if (selectedGenres.has('electronic') && typeof fallbackElectronicSubgenres === 'object') {
                Object.values(fallbackElectronicSubgenres).forEach(arr => {
                    if (Array.isArray(arr)) queries.push(...arr);
                });
            }
            if (selectedGenres.has('rnb') && typeof fallbackRnbSoulSubgenres === 'object') {
                Object.values(fallbackRnbSoulSubgenres).forEach(arr => {
                    if (Array.isArray(arr)) queries.push(...arr);
                });
            }
            if (selectedGenres.has('country') && typeof fallbackCountrySubgenres === 'object') {
                Object.values(fallbackCountrySubgenres).forEach(arr => {
                    if (Array.isArray(arr)) queries.push(...arr);
                });
            }
            if (selectedGenres.has('klassik') && typeof fallbackKlassikSubgenres === 'object') {
                Object.values(fallbackKlassikSubgenres).forEach(arr => {
                    if (Array.isArray(arr)) queries.push(...arr);
                });
            }
            if (selectedGenres.has('punk') && typeof fallbackPunkSubgenres === 'object') {
                Object.values(fallbackPunkSubgenres).forEach(arr => {
                    if (Array.isArray(arr)) queries.push(...arr);
                });
            }
            // Zusätzlich: Indie-Subgenres als Fallback, wenn Indie gewählt ist
            if (selectedGenres.has('indie') && typeof fallbackIndieSubgenres === 'object') {
                Object.values(fallbackIndieSubgenres).forEach(arr => {
                    if (Array.isArray(arr)) queries.push(...arr);
                });
            }
            // Zusätzlich: Jazz-Subgenres als Fallback, wenn Jazz gewählt ist
            if (selectedGenres.has('jazz') && typeof fallbackJazzSubgenres === 'object') {
                Object.values(fallbackJazzSubgenres).forEach(arr => {
                    if (Array.isArray(arr)) queries.push(...arr);
                });
            }
            // Zusätzlich: Techno-Subgenres als Fallback, wenn Techno gewählt ist
            if (selectedGenres.has('techno') && typeof fallbackTechnoSubgenres === 'object') {
                Object.values(fallbackTechnoSubgenres).forEach(arr => {
                    if (Array.isArray(arr)) queries.push(...arr);
                });
            }
            // Zusätzlich: Metal-Subgenres als Fallback, wenn Metal gewählt ist
            if (selectedGenres.has('metal') && typeof fallbackMetalSubgenres === 'object') {
                Object.values(fallbackMetalSubgenres).forEach(arr => {
                    if (Array.isArray(arr)) queries.push(...arr);
                });
            }
            const MAX_FALLBACK_ATTEMPTS = 15;
            const shuffledQueries = shuffleArray(queries);
            let attempts = 0;
            try {
                for (let round = 0; round < 2 && attempts < MAX_FALLBACK_ATTEMPTS; round++) {
                    for (let i = 0; i < shuffledQueries.length && attempts < MAX_FALLBACK_ATTEMPTS; i++) {
                        attempts += 1;
                        const phrase = shuffledQueries[i];
                        const { originalArtist, songTitle } = parseArtistAndTitle(phrase);
                        if (!originalArtist || !songTitle) continue;
                        // Fallback-Songs: ohne Jahresfilter suchen (iTunes gibt oft Remaster-Daten zurück)
                        let found = await findViaSpotifyPlayViaItunes(originalArtist, songTitle, null, null);
                        if (!found) found = await searchItunesForOriginal(originalArtist, songTitle, null, null);
                        if (found) {
                            const key = songKey(found.artistName, found.trackName);
                            if (playedSongKeys.has(key)) continue;
                            playedSongKeys.add(key);
                            currentSong = found;
                            applyReleaseYearOverride(currentSong);
                            const year = new Date(currentSong.releaseDate).getFullYear();
                            if (waitForFirstExplanation) {
                                const explanation = await fetchSongInfoWithTimeout(currentSong.artistName, currentSong.trackName, year, 35000);
                                songInfoPromise = Promise.resolve((explanation && explanation.trim()) ? explanation.trim() : getFallbackExplanationText(currentSong.artistName, currentSong.trackName, year));
                            } else {
                                songInfoPromise = fetchSongInfoFromOpenAI(currentSong.artistName, currentSong.trackName, year);
                            }
                            document.getElementById('audioPlayer').src = currentSong.previewUrl;
                            playBtn.disabled = false;
                            playBtn.classList.remove('loading');
                            setPlayButtonDisplay('▶');
                            resetPlayCountdown();
                            stopLoadingStatus(status, loadingId);
                            status.textContent = waitForFirstExplanation ? 'Klicke zum Abspielen' : 'Weiter geht\'s';
                            document.getElementById('roundCounter').textContent = `Runde ${roundNumber + 1} / ${totalRounds}`;
                            if (waitForFirstExplanation) preloadNextSongs();
                            return;
                        }
                    }
                }
            } catch (e) {
                console.error('Fallback-Suche:', e);
            }
            stopLoadingStatus(status, loadingId);
            status.textContent = 'Kein Song gefunden. Bitte Netz prüfen oder später erneut versuchen.';
            playBtn.classList.remove('loading');
            setPlayButtonDisplay('?');
            resetPlayCountdown();
        }

        function playPreview() {
            if (!currentSong) return;
            const audio = document.getElementById('audioPlayer');
            const playBtn = document.getElementById('playBtn');
            const status = document.getElementById('status');

            if (audio.paused) {
                audio.play();
                setPlayButtonDisplay('II');
                playBtn.classList.add('playing');
                status.textContent = 'Hört genau hin...';
                if (playCountdownIntervalId) clearInterval(playCountdownIntervalId);
                updatePlayCountdown();
                playCountdownIntervalId = setInterval(updatePlayCountdown, 100);
                if (!guessSubmitted) {
                    setTimeout(() => {
                        document.getElementById('playersGuessSection').classList.add('visible');
                        document.querySelector('.player-guess-input')?.focus();
                    }, 2000);
                }
            } else {
                audio.pause();
                if (playCountdownIntervalId) {
                    clearInterval(playCountdownIntervalId);
                    playCountdownIntervalId = null;
                }
                setPlayButtonDisplay('▶');
                playBtn.classList.remove('playing');
                status.textContent = 'Pausiert';
            }
        }

        document.getElementById('audioPlayer').addEventListener('ended', () => {
            resetPlayCountdown();
            setPlayButtonDisplay('▶');
            document.getElementById('status').textContent = 'Gebt eure Tipps ab!';
        });

        async function submitAllGuesses() {
            if (guessSubmitted || !currentSong) return;

            // Collect guesses
            let allValid = true;
            document.querySelectorAll('.player-guess-input').forEach((input, i) => {
                const val = parseInt(input.value);
                if (!val || val < 1900 || val > currentYear + 5) {
                    input.style.outline = '2px solid var(--cherry-rose)';
                    setTimeout(() => input.style.outline = '', 1000);
                    allValid = false;
                } else {
                    players[i].guess = val;
                    input.classList.add('submitted');
                    input.disabled = true;
                }
            });

            if (!allValid) return;

            guessSubmitted = true;
            document.getElementById('submitAllBtn').disabled = true;

            // Alle Eingaben mit Effekt aufdecken
            const inputs = document.querySelectorAll('.player-guess-input');
            inputs.forEach((input, idx) => {
                setTimeout(() => {
                    input.type = 'text';
                    input.classList.add('revealed');
                }, idx * 150);
            });

            // Warten bis alle aufgedeckt + kurz sichtbar, dann Ergebnis zeigen
            const revealDelay = inputs.length * 150 + 2500;
            await new Promise(r => setTimeout(r, revealDelay));

            const correctYear = new Date(currentSong.releaseDate).getFullYear();

            document.getElementById('resultYear').textContent = correctYear;
            const yearNoteEl = document.getElementById('resultYearNote');
            if (currentSong.yearNote) {
                yearNoteEl.textContent = currentSong.yearNote;
                yearNoteEl.style.display = 'block';
            } else {
                yearNoteEl.textContent = '';
                yearNoteEl.style.display = 'none';
            }
            // Album-Cover anzeigen
            const artworkEl = document.getElementById('resultArtwork');
            const artworkUrl = currentSong.artworkUrl100 ? currentSong.artworkUrl100.replace('100x100', '300x300') : '';
            if (artworkUrl) {
                artworkEl.src = artworkUrl;
                artworkEl.style.display = 'block';
            } else {
                artworkEl.style.display = 'none';
            }

            document.getElementById('resultSongTitle').textContent = currentSong.trackName || '';
            document.getElementById('resultArtistName').textContent = currentSong.artistName || '';

            // Song-Info: Block immer anzeigen, dann API oder Fallback-Erklärung laden
            const songInfoEl = document.getElementById('resultSongInfo');
            const songInfoTextEl = document.getElementById('songInfoText');
            if (songInfoEl) {
                songInfoEl.style.display = 'block';
                songInfoEl.style.visibility = 'visible';
            }
            const setExplanationText = (text) => {
                if (songInfoTextEl && text != null) songInfoTextEl.textContent = String(text).trim() || 'Keine Erklärung verfügbar.';
            };
            setExplanationText('Erklärung wird geladen…');

            (async () => {
                try {
                    const apiText = songInfoPromise ? await songInfoPromise : await fetchSongInfoFromOpenAI(currentSong.artistName, currentSong.trackName, correctYear);
                    if (apiText && apiText.trim()) {
                        setExplanationText(apiText.trim());
                    } else {
                        setExplanationText(getFallbackExplanationText(currentSong.artistName, currentSong.trackName, correctYear));
                        if (!apiText) console.warn('Song-Erklärung: API lieferte keinen Text – Fallback angezeigt.');
                    }
                } catch (e) {
                    console.warn('Song-Info anzeigen:', e);
                    setExplanationText(getFallbackExplanationText(currentSong.artistName, currentSong.trackName, correctYear));
                }
            })();

            // Sort players by accuracy
            const sorted = [...players].sort((a, b) => Math.abs(a.guess - correctYear) - Math.abs(b.guess - correctYear));

            document.getElementById('playerResults').innerHTML = sorted.map(p => {
                const diff = Math.abs(p.guess - correctYear);
                let cls = 'far';
                if (diff === 0) cls = 'perfect';
                else if (diff <= 5) cls = 'close';

                const isMobile = window.innerWidth < 400;
                let diffText = diff === 0 ? 'Perfekt!' :
                    isMobile ? `${diff} Jahr${diff > 1 ? 'e' : ''} (${p.guess})` :
                    `${diff} Jahr${diff > 1 ? 'e' : ''} daneben! (dein Tipp: ${p.guess})`;
                return `
                    <div class="player-result-row ${cls}">
                        <span class="player-result-name">${p.name}</span>
                        <span class="player-result-diff">${diffText}</span>
                    </div>
                `;
            }).join('');

            const q = encodeURIComponent(`${currentSong.artistName} ${currentSong.trackName}`);
            document.getElementById('streamingButtons').innerHTML = `
                <a href="spotify:search:${q}" class="stream-link spotify">Spotify</a>
                <a href="music://search?term=${q}" class="stream-link apple">Apple</a>
                <a href="deezer://www.deezer.com/search/${q}" class="stream-link deezer">Deezer</a>
                <a href="tidal://search/${q}" class="stream-link tidal">Tidal</a>
            `;

            // Update total scores for standings
            players.forEach(p => {
                const diff = Math.abs(p.guess - correctYear);
                p.totalDiff += diff;
            });
            roundNumber++;

            document.getElementById('playersGuessSection').classList.remove('visible');
            document.getElementById('result').classList.add('visible');
            document.getElementById('status').textContent = '';

            // Nach der letzten Runde automatisch Ranking anzeigen
            if (roundNumber >= totalRounds) {
                setTimeout(() => showStandings(), 2000);
            }
        }

        function showStandings() {
            const overlay = document.getElementById('standingsOverlay');
            const roundText = document.getElementById('standingsRound');
            const list = document.getElementById('standingsList');
            const title = document.getElementById('standingsTitle');
            const btn = document.getElementById('standingsBtn');

            const isGameOver = roundNumber >= totalRounds;
            title.textContent = isGameOver ? 'Endergebnis' : 'Zwischenstand';
            btn.textContent = isGameOver ? 'Neues Spiel' : 'Weiter spielen';
            roundText.textContent = `Nach ${roundNumber} von ${totalRounds} Runde${roundNumber > 1 ? 'n' : ''}`;

            // "Nochmal!" Button nur bei Spielende zeigen
            const buttonsContainer = document.getElementById('standingsButtons');
            const existingRestart = buttonsContainer.querySelector('.restart-btn');
            if (isGameOver && !existingRestart) {
                const restartBtn = document.createElement('button');
                restartBtn.className = 'restart-btn';
                restartBtn.textContent = 'Nochmal!';
                restartBtn.onclick = restartWithSameSettings;
                buttonsContainer.appendChild(restartBtn);
            } else if (!isGameOver && existingRestart) {
                existingRestart.remove();
            }

            // Sort by total difference (lowest is best)
            const sorted = [...players].sort((a, b) => a.totalDiff - b.totalDiff);

            list.innerHTML = sorted.map((p, i) => {
                const avg = roundNumber > 0 ? (p.totalDiff / roundNumber).toFixed(1) : 0;
                const scoreText = roundNumber > 0
                    ? `${p.totalDiff} Jahre Abweichung, ø ${avg} Jahre`
                    : `${p.totalDiff} Jahre Abweichung`;
                return `
                    <div class="standings-row">
                        <span class="standings-rank">${i + 1}.</span>
                        <span class="standings-name">${p.name}</span>
                        <span class="standings-score">${scoreText}</span>
                    </div>
                `;
            }).join('');

            overlay.classList.add('visible');
        }

        function hideStandings() {
            document.getElementById('standingsOverlay').classList.remove('visible');
            // Bei Spielende zurück zum Setup
            if (roundNumber >= totalRounds) {
                document.getElementById('gameScreen').style.display = 'none';
                document.getElementById('introScreen').style.display = 'none';
                document.getElementById('setupPlayers').style.display = 'block';
                roundNumber = 0;
                players.forEach(p => p.totalDiff = 0);
            }
        }

        function restartWithSameSettings() {
            document.getElementById('standingsOverlay').classList.remove('visible');
            roundNumber = 0;
            players.forEach(p => { p.totalDiff = 0; p.guess = null; });
            playedSongKeys.clear();
            songQueue = [];
            preloadedSongs = [];
            document.getElementById('result').classList.remove('visible');
            document.getElementById('playersGuessSection').classList.remove('visible');
            renderPlayerGuessRows();
            loadNewSong();
        }

        init();

        // Text Loop Animation für Intro (startet nach Logo-Animation)
        (function initTextLoop() {
            const claims = [
                '30 Sekunden hören.',
                'Jahr tippen.',
                'Punkte kassieren.'
            ];
            let currentIndex = 0;
            const container = document.getElementById('introTextLoop');
            if (!container) return;

            function showNext() {
                const currentEl = container.querySelector('.intro-text-loop-item');
                if (currentEl) {
                    currentEl.classList.add('exit');
                    setTimeout(() => {
                        currentIndex = (currentIndex + 1) % claims.length;
                        container.innerHTML = `<div class="intro-text-loop-item">${claims[currentIndex]}</div>`;
                    }, 300);
                }
            }

            // Warte bis Logo-Animation fertig ist, dann starte Text-Loop
            // Desktop: 1s, Mobile: 3s
            const isMobile = window.innerWidth <= 768;
            const delay = isMobile ? 3000 : 1000;
            setTimeout(() => {
                container.classList.add('active');
                setInterval(showNext, 2000);
            }, delay);
        })();

        // WebGL Dithering Shader Background (WebGL2 mit WebGL1-Fallback für Mobile)
        (function initDitheringShader() {
            const canvas = document.getElementById('wavyBackground');
            const opts = { alpha: false, failIfMajorPerformanceCaveat: false };
            let gl = canvas.getContext('webgl2', opts);
            const isWebGL1 = !gl;
            if (!gl) gl = canvas.getContext('webgl', opts) || canvas.getContext('experimental-webgl', opts);
            if (!gl) {
                console.warn('WebGL not supported');
                return;
            }

            // Shader sources (WebGL2 / GLSL ES 3.0)
            const vertexShaderSource = `#version 300 es
precision mediump float;
layout(location = 0) in vec4 a_position;
void main() { gl_Position = a_position; }`;

            const fragmentShaderSource = `#version 300 es
precision mediump float;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec4 u_colorBack;
uniform vec4 u_colorFront;
uniform float u_pxSize;
uniform float u_waveOffset;
out vec4 fragColor;

const int bayer8x8[64] = int[64](
   0, 32,  8, 40,  2, 34, 10, 42,
  48, 16, 56, 24, 50, 18, 58, 26,
  12, 44,  4, 36, 14, 46,  6, 38,
  60, 28, 52, 20, 62, 30, 54, 22,
   3, 35, 11, 43,  1, 33,  9, 41,
  51, 19, 59, 27, 49, 17, 57, 25,
  15, 47,  7, 39, 13, 45,  5, 37,
  63, 31, 55, 23, 61, 29, 53, 21
);

float getBayerValue(vec2 uv) {
  ivec2 pos = ivec2(mod(uv, 8.0));
  int index = pos.y * 8 + pos.x;
  return float(bayer8x8[index]) / 64.0;
}

void main() {
  float t = 0.5 * u_time;
  vec2 uv = gl_FragCoord.xy / u_resolution.xy;
  uv -= 0.5;
  float pxSize = u_pxSize;
  vec2 pxSizeUv = gl_FragCoord.xy;
  pxSizeUv -= 0.5 * u_resolution;
  pxSizeUv /= pxSize;
  vec2 pixelizedUv = floor(pxSizeUv) * pxSize / u_resolution.xy;
  pixelizedUv += 0.5;
  pixelizedUv -= 0.5;
  vec2 shape_uv = pixelizedUv * 4.0;
  shape_uv.y += u_waveOffset;
  float wave = cos(0.5 * shape_uv.x - 2.0 * t) * sin(1.5 * shape_uv.x + t) * (0.75 + 0.25 * cos(3.0 * t));
  float shape = 1.0 - smoothstep(-1.0, 1.0, shape_uv.y + wave);
  float dithering = getBayerValue(pxSizeUv) - 0.5;
  float res = step(0.5, shape + dithering);
  vec3 fgColor = u_colorFront.rgb * u_colorFront.a;
  float fgOpacity = u_colorFront.a;
  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;
  float bgOpacity = u_colorBack.a;
  vec3 color = fgColor * res;
  float opacity = fgOpacity * res;
  color += bgColor * (1.0 - opacity);
  opacity += bgOpacity * (1.0 - opacity);
  fragColor = vec4(color, opacity);
}`;

            // WebGL1 / GLSL ES 1.0 (Fallback für viele Mobile-Browser)
            const vertexShaderSourceWebGL1 = `attribute vec4 a_position;
void main() { gl_Position = a_position; }`;

            const fragmentShaderSourceWebGL1 = `precision mediump float;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec4 u_colorBack;
uniform vec4 u_colorFront;
uniform float u_pxSize;
uniform float u_waveOffset;

float getBayerValue(vec2 uv) {
  vec2 pos = mod(uv, 8.0);
  int ix = int(pos.x);
  int iy = int(pos.y);
  int index = iy * 8 + ix;
  float v = 0.0;
  if (index == 0) v = 0.0; else if (index == 1) v = 32.0; else if (index == 2) v = 8.0; else if (index == 3) v = 40.0;
  else if (index == 4) v = 2.0; else if (index == 5) v = 34.0; else if (index == 6) v = 10.0; else if (index == 7) v = 42.0;
  else if (index == 8) v = 48.0; else if (index == 9) v = 16.0; else if (index == 10) v = 56.0; else if (index == 11) v = 24.0;
  else if (index == 12) v = 50.0; else if (index == 13) v = 18.0; else if (index == 14) v = 58.0; else if (index == 15) v = 26.0;
  else if (index == 16) v = 12.0; else if (index == 17) v = 44.0; else if (index == 18) v = 4.0; else if (index == 19) v = 36.0;
  else if (index == 20) v = 14.0; else if (index == 21) v = 46.0; else if (index == 22) v = 6.0; else if (index == 23) v = 38.0;
  else if (index == 24) v = 60.0; else if (index == 25) v = 28.0; else if (index == 26) v = 52.0; else if (index == 27) v = 20.0;
  else if (index == 28) v = 62.0; else if (index == 29) v = 30.0; else if (index == 30) v = 54.0; else if (index == 31) v = 22.0;
  else if (index == 32) v = 3.0; else if (index == 33) v = 35.0; else if (index == 34) v = 11.0; else if (index == 35) v = 43.0;
  else if (index == 36) v = 1.0; else if (index == 37) v = 33.0; else if (index == 38) v = 9.0; else if (index == 39) v = 41.0;
  else if (index == 40) v = 51.0; else if (index == 41) v = 19.0; else if (index == 42) v = 59.0; else if (index == 43) v = 27.0;
  else if (index == 44) v = 49.0; else if (index == 45) v = 17.0; else if (index == 46) v = 57.0; else if (index == 47) v = 25.0;
  else if (index == 48) v = 15.0; else if (index == 49) v = 47.0; else if (index == 50) v = 7.0; else if (index == 51) v = 39.0;
  else if (index == 52) v = 13.0; else if (index == 53) v = 45.0; else if (index == 54) v = 5.0; else if (index == 55) v = 37.0;
  else if (index == 56) v = 63.0; else if (index == 57) v = 31.0; else if (index == 58) v = 55.0; else if (index == 59) v = 23.0;
  else if (index == 60) v = 61.0; else if (index == 61) v = 29.0; else if (index == 62) v = 53.0; else v = 21.0;
  return v / 64.0;
}

void main() {
  float t = 0.5 * u_time;
  vec2 uv = gl_FragCoord.xy / u_resolution.xy;
  uv -= 0.5;
  float pxSize = u_pxSize;
  vec2 pxSizeUv = gl_FragCoord.xy;
  pxSizeUv -= 0.5 * u_resolution;
  pxSizeUv /= pxSize;
  vec2 pixelizedUv = floor(pxSizeUv) * pxSize / u_resolution.xy;
  pixelizedUv += 0.5;
  pixelizedUv -= 0.5;
  vec2 shape_uv = pixelizedUv * 4.0;
  shape_uv.y += u_waveOffset;
  float wave = cos(0.5 * shape_uv.x - 2.0 * t) * sin(1.5 * shape_uv.x + t) * (0.75 + 0.25 * cos(3.0 * t));
  float shape = 1.0 - smoothstep(-1.0, 1.0, shape_uv.y + wave);
  float dithering = getBayerValue(pxSizeUv) - 0.5;
  float res = step(0.5, shape + dithering);
  vec3 fgColor = u_colorFront.rgb * u_colorFront.a;
  float fgOpacity = u_colorFront.a;
  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;
  float bgOpacity = u_colorBack.a;
  vec3 color = fgColor * res;
  float opacity = fgOpacity * res;
  color += bgColor * (1.0 - opacity);
  opacity += bgOpacity * (1.0 - opacity);
  gl_FragColor = vec4(color, opacity);
}`;

            function createShader(type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            const vsSource = isWebGL1 ? vertexShaderSourceWebGL1 : vertexShaderSource;
            const fsSource = isWebGL1 ? fragmentShaderSourceWebGL1 : fragmentShaderSource;
            const vertexShader = createShader(gl.VERTEX_SHADER, vsSource);
            const fragmentShader = createShader(gl.FRAGMENT_SHADER, fsSource);

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program error:', gl.getProgramInfoLog(program));
                return;
            }

            // Get uniform locations
            const uniforms = {
                u_time: gl.getUniformLocation(program, 'u_time'),
                u_resolution: gl.getUniformLocation(program, 'u_resolution'),
                u_colorBack: gl.getUniformLocation(program, 'u_colorBack'),
                u_colorFront: gl.getUniformLocation(program, 'u_colorFront'),
                u_pxSize: gl.getUniformLocation(program, 'u_pxSize'),
                u_waveOffset: gl.getUniformLocation(program, 'u_waveOffset')
            };

            // Setup position buffer
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // Colors: dark blue background, cherry rose front
            const colorBack = [15/255, 26/255, 46/255, 1]; // #0f1a2e
            const colorFront = [175/255, 18/255, 90/255, 0.6]; // #AF125A with opacity

            const startTime = Date.now();
            let animationId;

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            function render() {
                const isMobile = window.innerWidth <= 768;
                const pxSize = isMobile ? 4 : 3;
                const waveOffset = isMobile ? 1.5 : 0; // Mobile: Welle im unteren Drittel
                const speed = 0.5;
                const currentTime = (Date.now() - startTime) * 0.001 * speed;

                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.useProgram(program);

                gl.uniform1f(uniforms.u_time, currentTime);
                gl.uniform2f(uniforms.u_resolution, canvas.width, canvas.height);
                gl.uniform4fv(uniforms.u_colorBack, colorBack);
                gl.uniform4fv(uniforms.u_colorFront, colorFront);
                gl.uniform1f(uniforms.u_pxSize, pxSize);
                gl.uniform1f(uniforms.u_waveOffset, waveOffset);

                gl.drawArrays(gl.TRIANGLES, 0, 6);
                animationId = requestAnimationFrame(render);
            }

            resize();
            window.addEventListener('resize', resize);
            window.addEventListener('orientationchange', function() { setTimeout(resize, 100); });
            // Mobile: Nach erstem Paint nochmal dimensionieren (vermeidet leeres Canvas)
            requestAnimationFrame(function() { requestAnimationFrame(resize); });
            render();
        })();
    </script>
</body>
</html>
